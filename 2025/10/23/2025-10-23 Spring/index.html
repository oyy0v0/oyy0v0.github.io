<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring | oyy0v0😼</title><meta name="author" content="oyy0v0"><meta name="copyright" content="oyy0v0"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="知识分享">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring">
<meta property="og:url" content="https://oyy0v0.top/2025/10/23/2025-10-23%20Spring/index.html">
<meta property="og:site_name" content="oyy0v0😼">
<meta property="og:description" content="知识分享">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/17.jpg">
<meta property="article:published_time" content="2025-10-23T13:40:00.000Z">
<meta property="article:modified_time" content="2025-11-26T12:11:29.894Z">
<meta property="article:author" content="oyy0v0">
<meta property="article:tag" content="-Spring全家桶">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/17.jpg"><link rel="shortcut icon" href="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/%E7%8C%AB.svg"><link rel="canonical" href="https://oyy0v0.top/2025/10/23/2025-10-23%20Spring/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-26 20:11:29'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4658720_723un29n3vn.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/readPercent.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/7.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw icon-guanyu"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/17.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="oyy0v0😼"><span class="site-name">oyy0v0😼</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw icon-guanyu"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-23T13:40:00.000Z" title="发表于 2025-10-23 21:40:00">2025-10-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-26T12:11:29.894Z" title="更新于 2025-11-26 20:11:29">2025-11-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>86分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h2><p>Spring框架的控制反转IoC 容器。</p>
<p>Spring面相切面编程 AOP 技术。</p>
<p>此外还有Spring和AspectJ</p>
<h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><h4 id="Spring-IoC容器和Bean简介"><a href="#Spring-IoC容器和Bean简介" class="headerlink" title="Spring IoC容器和Bean简介"></a>Spring IoC容器和Bean简介</h4><p>原本是 “对象自己找依赖”（比如 A 类要用到 B 类，A 自己 new B、自己找 B 的实例），现在是 “容器给对象送依赖”（A 不用管 B 怎么来，容器提前准备好 B，在创建 A 时主动 “塞” 给 A）—— 这种 “找依赖的权力从对象手里转到容器手里” 的反转，就是 IoC；而容器 “塞依赖” 的具体动作，就是 DI（依赖注入）</p>
<p>IoC 是 “设计原则”（核心思想是 “反转依赖控制权”），DI 是 “实现方式”（具体怎么把依赖给对象）—— 二者本质是同一概念的不同角度描述，Spring 用 DI 的方式实现了 IoC 原则。</p>
<p>一个对象（比如 A 类）要和其他对象（比如 B 类、C 类，也就是 A 的 “依赖”）合作，不用自己去创建或查找这些依赖，只需要 “明确告诉容器自己需要什么”—— 告诉的方式有 3 种：</p>
<ul>
<li>构造参数：A 的构造方法里写<code>public A(B b) &#123; ... &#125;</code>（告诉容器 “我需要 B”）；</li>
<li>工厂方法参数：如果 A 是通过工厂方法创建的，工厂方法里写<code>public static A createA(B b) &#123; ... &#125;</code>（告诉容器 “创建我需要 B”）；</li>
<li>属性设置：A 里写<code>private B b;</code> + setter 方法<code>public void setB(B b) &#123; ... &#125;</code>（告诉容器 “我需要 B，创建后给我设进来”）。</li>
</ul>
<p>Spring 的核心是 “IoC 容器”（可以理解为 “对象管家”），容器会提前创建好所有需要的依赖对象（比如 B、C），当容器创建 A（Spring 里的对象叫 “bean”）时，会按照 A 之前 “告诉” 的方式（构造参数 / 工厂参数 / 属性），把 B、C 主动 “塞” 到 A 里 —— 这个 “塞” 的动作就是 “依赖注入（DI）”。</p>
<ul>
<li>这是最关键的一句，解释 “控制反转” 的 “反转” 到底是什么：<ul>
<li>「传统方式（没有 IoC）」：Bean 自己控制依赖 → A 要用到 B，A 自己用<code>B b = new B();</code>（直接构建），或者自己找个 “服务定位器” 查 B 的实例（比如<code>B b = ServiceLocator.getB();</code>）—— 控制权在 A 手里。</li>
<li>「IoC 方式」：容器控制依赖 → A 不用自己 new B、不用自己查 B，控制权转到了 IoC 容器手里 —— 这就是 “控制的反转”（从对象反转到容器）。</li>
</ul>
</li>
</ul>
<p>例子</p>
<p>IoC 方式（Spring 实现）：容器控制依赖，注入给对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataBaseDao：还是原来的类，不用改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataBaseDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Score&gt; <span class="title function_">queryScores</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ScoreService：只“声明依赖”，不“创建依赖”（控制权交给容器）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScoreService</span> &#123;</span><br><span class="line">    <span class="comment">// 声明需要DataBaseDao（通过属性+setter，告诉容器自己需要它）</span></span><br><span class="line">    <span class="keyword">private</span> DataBaseDao dataBaseDao;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setter方法：给容器提供“注入依赖”的入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataBaseDao</span><span class="params">(DataBaseDao dataBaseDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataBaseDao = dataBaseDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateScore</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Score&gt; scores = dataBaseDao.queryScores(); <span class="comment">// 直接用容器注入的依赖</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring配置（告诉容器要管理哪些bean，以及依赖关系）</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;dataBaseDao&quot;</span> class=<span class="string">&quot;com.example.DataBaseDao&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;scoreService&quot;</span> class=<span class="string">&quot;com.example.ScoreService&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 容器创建scoreService时，把dataBaseDao注入进去（调用setter方法） --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataBaseDao&quot;</span> ref=<span class="string">&quot;dataBaseDao&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Spring-IoC容器的两个核心组件"><a href="#Spring-IoC容器的两个核心组件" class="headerlink" title="Spring IoC容器的两个核心组件"></a>Spring IoC容器的两个核心组件</h4><p><strong>BeanFactory 和 ApplicationContext</strong></p>
<p>Spring IoC 容器核心功能由两个接口支撑，他们的关系类似 基础班工具和升级版工具，ApplicationContext包含BeanFactory所有功能并且新增了更多特性。</p>
<p>1、BeanFactory接口</p>
<p>核心功能，能创建对象 Bean，组装对象之间的依赖关系，比如A 依赖B ，就会把 B 塞给 A ，不管对象是什么类型都能管。</p>
<p>2、ApplicationContext 接口</p>
<p>是BeanFactory 的 子接口，相当于继承了基础款的所有功能，是更强大的企业级 IoC容器。</p>
<p>新增了 AOP集成更方便：直接支持Spring AOP 不用额外复杂配置</p>
<p>国际化支持：能支持多语言消息 中文环境显示你好，英文环境显示Hello</p>
<p>事件发布：支持 事件通知 机制，比如某个对象状态变化时，自动通知其他关心这个变化的对象。</p>
<p>场景化扩展：针对特定场景提供专用容器，比如WebApplicationContext 专门给 Web 应用 比如Spring MVC 用，能更好地适配Web环境。</p>
<h4 id="Bean的概念"><a href="#Bean的概念" class="headerlink" title="Bean的概念"></a>Bean的概念</h4><p>Bean是Spring IoC容器管理的特殊对象，理解他的关系是区分 普通对象 和 Spring Bean</p>
<p>1、普通对象 vs Spring Bean</p>
<p>普通对象是自己new创建的对象，生命周期由自己控制，创建、销毁全靠代码 <strong>创建 -&gt; 使用 -&gt; 不可达 -&gt; 销毁/回收</strong>。</p>
<p>Spring Bean：由Spring IoC容器，BeanFactory或者ApplicationContext负责实例化（创建对象），组装（处理依赖，比如给对象的属性赋值）、管理（控制对象的生命周期，比如什么时候创建，什么时候销毁）</p>
<p>2、<strong>Bean的 配置元数据</strong></p>
<p>容器怎么知道要创建哪些 Bean、Bean 之间有什么依赖关系？靠 “配置元数据”—— 就是你告诉容器的 “清单”，比如：</p>
<ul>
<li>XML 配置文件（<code>&lt;bean id=&quot;userService&quot; class=&quot;com.xxx.UserService&quot;&gt;...&lt;/bean&gt;</code>）；</li>
<li>注解（<code>@Component</code>、<code>@Service</code>等，标记哪些类需要被容器管理）；</li>
<li>Java 配置类（<code>@Configuration</code> + <code>@Bean</code>注解，手动定义 Bean）。</li>
</ul>
<p>这些元数据里会写明：要创建哪个类的对象、对象的依赖是谁、对象的初始化参数是什么等，容器照着 “清单” 干活。</p>
<h4 id="IOC容器的概念"><a href="#IOC容器的概念" class="headerlink" title="IOC容器的概念"></a>IOC容器的概念</h4><h5 id="Spring-IoC容器的工作机制"><a href="#Spring-IoC容器的工作机制" class="headerlink" title="Spring IoC容器的工作机制"></a>Spring IoC容器的工作机制</h5><p>1、ApplicationContext 是 Spring IoC 容器的 实体代表，相当于一个智能工厂，核心职责有三个</p>
<ul>
<li>实例化：按照规则创建应用程序需要的对象，比如Service、Dao等</li>
<li>配置：给对象设置属性，比如给UserService的name属性赋值</li>
<li>组装：处理对象之间的依赖 比如OrderService需要UserService，容器会自动把UserService 连接到 OrderService里</li>
</ul>
<p>2、核心依赖，容器做这些事的依据是配置元数据，相当于给工程的生产清单，清单里写着：</p>
<ul>
<li>要创建哪些类的对象，比如com.xxx.UserService</li>
<li>每个对象的属性怎么设置，比如UserService的timeout设置为3000</li>
<li>对象之间的依赖关系，比如OrderService 依赖 UserService</li>
</ul>
<p>3、元数据格式：生产清单可以用3种形式写：</p>
<ul>
<li>xml 文件 传统方式：比如 <code>&lt;bean id=&quot;userService&quot; class=&quot;com.xxx.UserService&quot;/&gt;</code></li>
<li>Java注解：比如在类上标@Service，告诉容器这个类要被管理</li>
<li>Java代码：配置类的方式，比如用@Configuration + @Bean注解手动定义对象。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/Spring-23.png" alt=""></p>
<p>思路:</p>
<p>（1）定义xml文件，里面定义bean标签，因为后续每个bean标签会被解析为一个对象</p>
<p>（2）解析xml文件(dom4j)，解析的时候，会解析xml文件中的bean标签，每个bean标签转换为一个bean对象，此对象包含两个属性：id、class，此对象用来存放bean的id和class值。</p>
<p>（3）因为xml文件中bean标签可能是多个，所以定义一个List集合，存储bean对象。</p>
<p>（4）遍历List集合，得到每一个bean对象，通过bean对象的class属性，反射创建对应的对象。</p>
<p>（5）对象创建好以后，将bean对象的id和反射创建的对象，放入map集合中。</p>
<p>（6）定义一个工厂，（2）-（5）步骤放在工厂的构造器中完成</p>
<p>（7）工厂中定义获取对象的方法，通过id从map集合中获取对象。</p>
<h5 id="ApplicationContext的具体实现和使用场景"><a href="#ApplicationContext的具体实现和使用场景" class="headerlink" title="ApplicationContext的具体实现和使用场景"></a>ApplicationContext的具体实现和使用场景</h5><p>Spring提供了多个ApplicationContext的视线，就像工厂有 不同的生产线，适配不同的场景。</p>
<p>1、独立应用 非Web  常用的两种</p>
<ul>
<li>ClassPathXmlApplicationContext：从项目的 类路径 比如 src/main/resources目录 ，读取XML配置文件</li>
<li>FileSystemXmlApplicationContext：从操作系统的文件系统路径 比如 D:/config/spring.xml 读取 xml 配置</li>
</ul>
<p>2、Web应用：用专门的WebApplicationContext，适配Tomcat等Web 服务环境。</p>
<p>3、简化配置的技巧：</p>
<ul>
<li>虽然XML是传统格式，但可以用少量XML配置 “开启注解支持” 比如 <code>&lt;context:component-scan&gt;</code> ,之后主要使用@Service，@Autowired等注解管理Bean，不用写大量XML</li>
<li>实际开发中几乎不用手动写代码创建容器：比如Web应用只需要在web.xml里加几行模版配置，容器会由 Web 服务器自动初始化</li>
</ul>
<h5 id="配置元数据"><a href="#配置元数据" class="headerlink" title="配置元数据"></a>配置元数据</h5><p>Spring IoC容器消费一种配置元数据。这种配置元数据代表了你，作为一个应用开发者，如何告诉Spring容器在你的应用中实例化、配置和组装对象。</p>
<p><code>基于XML的元数据并不是配置元数据的唯一允许形式。Spring IOC 容器本身与这种配置元数据的实际编写格式是完全解耦的。如今许多开发者用基于Java的配置</code></p>
<p>关于在Spring容器中使用其他形式的元数据的信息，请参见。</p>
<ul>
<li>基于注解的配置 使用基于注解的配置元数据定义Bean。</li>
<li>Java-based configuration 通过使用Java而不是XML文件来定义你的应用类外部的Bean。要使用这些特性，请参阅 <code>@Configuration</code> <code>@Bean</code>, <code>@Import</code>, 和 <code>@DependsOn</code>注解。</li>
</ul>
<p>Spring的配置包括至少一个，通常是一个以上的Bean定义，容器必须管理这些定义。基于XML的配置元数据将这些Bean配置为顶层 <code>&lt;beans/&gt;</code> 元素内的 <code>&lt;bean/&gt;</code> 元素。Java配置通常使用 <code>@Configuration</code> 类中的 <code>@Bean</code> 注解的方法。</p>
<p>这些Bean的定义对应于构成你的应用程序的实际对象。通常，你会定义服务层对象、持久层对象（如存储库或数据访问对象（DAO））、表现对象（如Web控制器）、基础设施对象（如JPA <code>EntityManagerFactory</code>）、JMS队列等等。通常，人们不会在容器中配置细粒度的domain对象，因为创建和加载domain对象通常是 repository 和业务逻辑的责任。</p>
<p>下面的例子显示了基于XML的配置元数据的基本结构。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 这个bean的合作者和配置在这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- c这个bean的合作者和配置在这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 更多bean 定义在这里 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><code>id</code> 属性是一个字符串，用于识别单个Bean定义。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>class</code> 属性定义了 Bean 的类型，并使用类的全路径名。</td>
</tr>
</tbody>
</table>
</div>
<p><code>id</code> 属性的值可以用来指代协作对象。本例中没有显示用于引用协作对象的XML。</p>
<h5 id="实例化一个容器"><a href="#实例化一个容器" class="headerlink" title="实例化一个容器"></a>实例化一个容器</h5><p>配置好元数据了，那么就可以实例化一个容器然后就可以根据配置在容器中new对象了</p>
<p>在ApplicationContext 构造函数的一条或者多条路径是资源字符串，它让容器从各种外部资源（如本地文件系统、Java CLASSPATH）加载配置元数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>,<span class="string">&quot;daos.xml&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后接口层service的对象引用的持久层的dao层对象，然后dao层的对象引用具体的类，这样子的配置类有些许的不同，下面是例子</p>
<p>下面的例子显示了 service 对象（<code>services.xml</code>）配置文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;petStore&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;itemDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;itemDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面的例子显示了数据访问对象（data access object） <code>daos.xml</code> 文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;itemDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看出，在xml配置中，</p>
<p>service层的时候由于引用的是对象，所以就用 id 配置service的具体名称 和 class 来制定service的实现类路径，然后在标签下用property标签用name来重新自定义引用的dao的名称，用ref来确定 service用到的dao的名称</p>
<p>dao层的时候，直接用id来制定dao层的名称用class来制定dao层的类路径。</p>
<h5 id="拆分、组织Spring的XML配置元数据"><a href="#拆分、组织Spring的XML配置元数据" class="headerlink" title="拆分、组织Spring的XML配置元数据"></a>拆分、组织Spring的XML配置元数据</h5><p>当项目的xml文件过多的时候，为了让复杂的项目配置更清晰，设置了几个规则，核心目的就是拆分，组织xml配置元数据，而不是把所有的Bean定义写在一个XML，臃肿难以维护。</p>
<p><strong>两种整合多XML配置的方式</strong></p>
<p>1、创建ApplicationContext 容器 时，直接传入所有XML文件的路径，容器会自动合并所有Bean定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 示例：加载“服务层”和“数据层”的2个XML文件</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(</span><br><span class="line">    &quot;services.xml&quot;,  // 服务层配置（如UserService、OrderService）</span><br><span class="line">    &quot;daos.xml&quot;       // 数据层配置（如UserDao、OrderDao）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>2、用<code>&lt;import/&gt; 标签导入</code>（更常用）</p>
<p>在一个 ’主XML配置文件‘ 中，通过<code>&lt;import resource=&quot;文件路径&quot;/&gt;</code>标签导入其他XML，相当于把多个XML ‘合并’成一个</p>
<p>主配置文件（如<code>applicationContext.xml</code>）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入服务层配置：和主文件在同一目录/classpath位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;services.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入资源配置：在主文件所在目录的“resources”子目录下 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;resources/messageSource.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前导斜线会被忽略，建议不写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;/resources/themeSource.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 主文件也可直接定义Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;systemConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.SystemConfig&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>容器只用加载主xml，就能自动加载所有导入的子XML。</p>
<p><strong>XML导入的路径规则</strong></p>
<p>首先classpath是Java运行时JVM用来查找类文件.clssh和资源文件xml等的路径集合</p>
<p>1、spring项目默认会给一个resources文件，在该文件夹下默认就是classpath路径，也就是说如果把xml放在里面就直接写文件名就好了不用配置文件路径。</p>
<p>2、如果需要配置就需要配置一下项目路径，然后不要写前导斜线</p>
<p>用`$ {..}这样的占位符语法，在运行时读取JVM系统属性，动态拼接路径.</p>
<p>那么这个占位符的值可以从多个来源获取，优先级如下</p>
<p>1、JVM系统属性在启动命令的时候 java -Dxxx xxx.jar这样启动的时候</p>
<p>2、操作系统变量</p>
<p>3、.yml配置文件</p>
<p>在spring中需要配置占位符解析，在springboot中自动启用，无需配置。 </p>
<p>用context命名空间开启注解扫描，在xml里面配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 头部声明context命名空间和对应的Schema --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> &lt;!<span class="attr">--</span> <span class="attr">声明context命名空间</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">                           https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                           http://www.springframework.org/schema/context <span class="comment">&lt;!-- 引入context的Schema --&gt;</span></span><br><span class="line">                           https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 用context命名空间的标签开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- base-package：指定要扫描的包（容器会递归扫描这个包下所有带注解的类） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example.service, com.example.dao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>来开启扫描功能。</p>
<h5 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h5><p>现在注册好了，又配置扫描好了，这样所有的配置已经准备就绪开始使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建和配置bean</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索配置的实例</span></span><br><span class="line"><span class="type">PetStoreService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用配置的实例</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>
<h4 id="Bean概览"><a href="#Bean概览" class="headerlink" title="Bean概览"></a>Bean概览</h4><h5 id="Bean包含的核心信息与容器的关系"><a href="#Bean包含的核心信息与容器的关系" class="headerlink" title="Bean包含的核心信息与容器的关系"></a>Bean包含的核心信息与容器的关系</h5><p>容器的核心功能是管理Bean，容器内部通过BeanDefinition对象 存储Bean的定义信息，相当于Bean的数字档案，记录了创建和管理Bean的所有关键参数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>核心属性</th>
<th>作用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bean 的 “身份标识”</strong></td>
<td>Class、Name</td>
<td>- Class：Bean 的全路径类名（如<code>com.example.UserService</code>），容器反射创建实例- Name：Bean 的唯一标识符（如 XML 的<code>id</code>），用于容器内引用</td>
</tr>
<tr>
<td><strong>Bean 的 “行为规则”</strong></td>
<td>Scope、Lazy initialization mode</td>
<td>- Scope：Bean 的作用域（如单例<code>singleton</code>、原型<code>prototype</code>），决定实例数量和生命周期- Lazy：是否懒加载（容器启动时不创建，首次使用时创建）</td>
</tr>
<tr>
<td><strong>Bean 的 “依赖关系”</strong></td>
<td>Constructor arguments、Properties、Autowiring mode</td>
<td>- 前两者：手动指定依赖（构造参数 / 属性注入）- Autowiring mode：自动装配规则（如按类型 / 名称注入依赖），减少手动配置</td>
</tr>
<tr>
<td><strong>Bean 的 “生命周期”</strong></td>
<td>Initialization method、Destruction method</td>
<td>- 初始化方法：Bean 实例化后执行（如资源初始化）- 销毁方法：Bean 销毁前执行（如资源释放）</td>
</tr>
</tbody>
</table>
</div>
<p>1、Class 全路径类名，容器通过反射创建实例</p>
<p>2、Name 名称，Bean的唯一表示，用于容器内区分和引用</p>
<p>3、Scope 作用域 ，Bean的生命周期范围，比如单例singleton、原型prototype，决定容器创建Bean的实例数量和存活时间</p>
<p>4、构造参数/属性 ，一来注入的关键信息，指定Bean创建需要的参数或者属性值，以及依赖的其他Bean合作者</p>
<p>5、Autowiring mode自动装配模式 ，容器自动匹配并注入依赖的规则（如按类型、按名称），减少手动配置。</p>
<p>6、懒加载模式， 指定Bean 是否在容器启动时创建（默认立即创建），还是首次使用时才创建。</p>
<p>7、初始化/销毁方法， Bean生命周期回调方法，分别在Bean初始化完成后，销毁前执行</p>
<h4 id="实例化Bean"><a href="#实例化Bean" class="headerlink" title="实例化Bean"></a>实例化Bean</h4><p>Spring容器有三种方法实例化Bean</p>
<p>1、用构造函数实例化：容器通过反射调用构造函数直接创建 Bean,这类似于Java中的new 操作符。这个是根据bena中的id得到bean的名称还有bean中的class知道class类的位置，然后利用class.forname这个反射方法利用默认构造器在容器初始化的时候进行实例化。</p>
<p>2、用静态工厂方法进行实例化：容器调用类的静态工厂方法来创建Bean。这个时候需要在Bean标签里面用 factory -m 属性来制定工厂方法名称，并且这个方法必须是静态方法，因为实在初始化中开始创建的。</p>
<p>3、用实例工厂方法进行实例化：bean调用现有的Bean的非静态方法来创建新Bean。配置的时候，class属性留空，factory - bean 属性制定包含实例方法的Bean的名称，再用 factory - method 属性设置工厂方法名称</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory</span> <span class="attr">-</span> <span class="attr">bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory</span> <span class="attr">-</span> <span class="attr">method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>4、确定Bean的运行时类型：由于Bean元数据定义中的类可能与实际运行时类型不同，且AOP代理可能会包装Bean实例，所以确定Bean运行时可以用BeanFactory.getType方法来获取Bean的实际运行时类型。</p>
<p><strong>总结：静态方法可以不受IOC容器管控也能使用，然后方法三是利用IOC容器中已经实例化后的Bean的初始化方法来创建另一个Bean</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>现在IOC容器已经被创建了，配置也配置好了，那么Bean是如何纳入容器管理，Bean又是如何初始化的呢？</p>
<ol>
<li><p>容器启动（如<code>ClassPathXmlApplicationContext</code>初始化），触发<code>refresh</code>过程，加载并解析配置元数据；</p>
</li>
<li><p>将解析结果封装为 BeanDefinition，注册到<code>BeanDefinitionRegistry</code>（内部 Map）；</p>
</li>
<li><p>容器根据 Bean 的作用域和懒加载设置，在合适的时机（启动时或getBean时）通过AbstractBeanFactory</p>
<p>的实现类创建 Bean：</p>
<ul>
<li>先反射实例化原始对象；</li>
<li>再进行属性填充（处理<code>@Value</code>、<code>@Autowired</code>等依赖）；</li>
<li>执行初始化逻辑（<code>InitializingBean</code>、<code>init-method</code>等）；</li>
</ul>
</li>
<li><p>单例 Bean 存入<code>singletonObjects</code>（单例池），原型 Bean 直接返回，最终通过<code>getBean</code>获取并使用</p>
</li>
</ol>
<h4 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h4><p>上面已经知道IOC容器如何创建实例Bean这里讲解如何注入属性。</p>
<p><strong>两种DI的实现方式 构造器注入 和 Setter 注入</strong></p>
<p>1、构造器注入</p>
<p>这种注入方式注入依赖后不可修改，一般为final修饰的，一般在需要强制注入的场景。</p>
<p>配置方式：无歧义的时候，直接按参数顺序配置</p>
<p>有歧义的时候，通过type 参数类型、index参数索引，从0开始、name参数名消除歧义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用index消歧：第一个参数为int，第二个为String --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> years; <span class="comment">// 构造器注入后不可修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ultimateAnswer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依赖通过构造器传入，由容器注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(<span class="type">int</span> years, String ultimateAnswer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.years = years;</span><br><span class="line">        <span class="built_in">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、基于Setter的依赖注入</p>
<p>这个是容器先通过无参构造器/无参静态工厂创建Bean，再调用Setter方法注入依赖，依赖后续可以修改</p>
<p>通过<code>&lt;property&gt;</code>标签制定属性名和依赖，支持直接引用其他Bean 利用ref属性，或者设置基本类型值 value属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;simpleMovieLister&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.SimpleMovieLister&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入依赖的MovieFinder Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;movieFinder&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;movieFinder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieFinder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.MovieFinder&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder; <span class="comment">// 可选依赖，可后续修改</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Setter方法供容器注入依赖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="循环依赖流程"><a href="#循环依赖流程" class="headerlink" title="循环依赖流程"></a>循环依赖流程</h5><p>场景：Bean A构造器依赖 Bean B,Bean B构造器依赖 Bean A，形成循环。容器会检测到这种循环，抛出<code>BeanCurrentlyInCreationException</code></p>
<h5 id="依赖配置细节"><a href="#依赖配置细节" class="headerlink" title="依赖配置细节"></a>依赖配置细节</h5><p>1、xml中配置的value属性，Spring会自动将字符串转换为目标类型比如int 、 boolean</p>
<ul>
<li>```xml<br><bean id="dataSource" class="..."><pre><code>&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
&lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
</code></pre>&lt;/bean&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 简化方式：使用`p命名空间`（属性式配置），如`p:username=&quot;root&quot;`，减少嵌套标签。</span><br><span class="line"></span><br><span class="line">2、引用其他Bean 协作者</span><br><span class="line"></span><br><span class="line">- 通过`&lt;ref bean=&quot;beanId&quot;/&gt;`引用容器中的其他 Bean，确保依赖的 Bean 先初始化。（这个是容器做的不需要手动排序，容器会先扫描BeanDefinition然后会根据依赖进行初始化的排序）</span><br><span class="line">- 父容器引用：使用`&lt;ref parent=&quot;beanId&quot;/&gt;`引用父容器中的 Bean（适用于容器分层场景）。</span><br><span class="line">- 简化方式：`p命名空间`中用`p:属性名-ref=&quot;beanId&quot;`（如`p:user-ref=&quot;userBean&quot;`）。</span><br><span class="line"></span><br><span class="line">在Spring中，容器是可以分层的，你可以有多个ApplicationContext，他们之间形成父子关系</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 父容器：通常放公共组件（数据源、事务管理器等）</span><br><span class="line">ApplicationContext parent = new ClassPathXmlApplicationContext(&quot;parent-config.xml&quot;);</span><br><span class="line"></span><br><span class="line">// 子容器：有自己的 Bean，也可以访问父容器的 Bean</span><br><span class="line">ApplicationContext child = new ClassPathXmlApplicationContext(&quot;child-config.xml&quot;);</span><br><span class="line">child.setParent(parent); // 设置父子关系</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在 child-config.xml 中 --&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.example.UserService&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; </span><br><span class="line">    &lt;!-- ❌ 默认先在本容器找，找不到就报错 --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.example.UserService&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; parent=&quot;dataSource&quot;/&gt; </span><br><span class="line">    &lt;!-- ✅ 明确表示：去父容器里找这个 Bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️ 注意：<code>ref</code> 和 <code>parent</code> 是不同的：</p>
</blockquote>
<ul>
<li><code>ref=&quot;xxx&quot;</code>：先在当前容器找，找不到再去父容器找（默认行为）</li>
<li><code>parent=&quot;xxx&quot;</code>：<strong>强制只在父容器中查找</strong>，不在本地容器中找</li>
</ul>
<p>3、内部Bean</p>
<ul>
<li><p>在<code>&lt;property&gt;</code>或<code>&lt;constructor-arg&gt;</code>内部直接定义 Bean（无需<code>id</code>），仅供当前 Bean 使用，无法被外部引用。</p>
</li>
<li><p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;outerBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;innerBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span> <span class="comment">&lt;!-- 内部Bean --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>4、集合类型（List、Set、Map、Properties）</p>
<ul>
<li><p>分别使用<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签配置，支持嵌套值或 Bean 引用。</p>
</li>
<li><p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;bean2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>集合合并：子 Bean 可通过<code>merge=&quot;true&quot;</code>继承父 Bean 的集合属性，并覆盖重复键值。</p>
</li>
</ul>
<p>5、null与空字符串</p>
<ul>
<li>空字符串：<code>&lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;</code></li>
<li>null 值：<code>&lt;property name=&quot;email&quot;&gt;&lt;null/&gt;&lt;/property&gt;</code></li>
</ul>
<p>6、构造函数参数的快捷配置</p>
<ul>
<li>使用<code>c命名空间</code>通过属性指定构造函数参数，如<code>c:username=&quot;root&quot;</code>（按名称）或<code>c:_0=&quot;root&quot;</code>（按索引，<code>_</code>避免 XML 语法冲突）。</li>
</ul>
<p>7、依赖关系的特殊处理</p>
<ul>
<li>1、通过depends-on 强制初始化顺序<ul>
<li>当 Bean A 依赖 Bean B 的初始化（但无需注入 B），用<code>depends-on</code>确保 B 先初始化。</li>
<li>示例：<code>&lt;bean id=&quot;A&quot; class=&quot;...&quot; depends-on=&quot;B, C&quot;/&gt;</code>（B 和 C 先于 A 初始化）。</li>
<li>单例 Bean 中，<code>depends-on</code>还会控制销毁顺序（依赖的 Bean 后销毁）。</li>
</ul>
</li>
<li>2、懒加载 lazy-init<ul>
<li>默认情况下，单例 Bean 在容器启动时预初始化；设置<code>lazy-init=&quot;true&quot;</code>后，首次调用<code>getBean()</code>时才初始化。</li>
<li>容器级配置：<code>&lt;beans default-lazy-init=&quot;true&quot;&gt;</code>（所有 Bean 默认懒加载）。</li>
<li>注意：若懒加载 Bean 被非懒加载 Bean 依赖，仍会在容器启动时初始化。</li>
</ul>
</li>
</ul>
<p>8、自动注入</p>
<p>Spring可以自动解析Bean之间的依赖关系，减少显示配置，拥有4种模式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>no</code>（默认）</td>
<td>不自动注入，需显式通过<code>&lt;ref&gt;</code>配置。</td>
</tr>
<tr>
<td><code>byName</code></td>
<td>按属性名匹配容器中的 Bean（如<code>setUser(...)</code>匹配名为<code>user</code>的 Bean）。</td>
</tr>
<tr>
<td><code>byType</code></td>
<td>按属性类型匹配容器中的 Bean（若存在多个同类型 Bean，抛出异常）。</td>
</tr>
<tr>
<td><code>constructor</code></td>
<td>类似<code>byType</code>，但用于构造函数参数（无匹配类型则抛异常）。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>限制</strong>：无法自动注入基本类型、String 等；显式配置（如<code>&lt;property&gt;</code>）优先级高于自动注入。</li>
<li><strong>排除自动注入</strong>：通过<code>autowire-candidate=&quot;false&quot;</code>标记 Bean，使其不参与自动注入候选。</li>
<li><strong>优先候选</strong>：通过<code>primary=&quot;true&quot;</code>标记 Bean，在多匹配时优先被选中。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;computer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Computer&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/image-20251026154320663.png" alt="image-20251026154320663"></p>
<p>在实际开发中通常用注解@Resource来配置</p>
<p>9、方法注入</p>
<p>这个解决的是单例Bean依赖原型Bean，假设一个单例Bean里面依赖了一个task是个原型Bean，然后每次都运行打印task的id，但是由于单例Bean是单例的那么这里的task只会被注入一次，即使task是原型模式，也只能拿到第一个实例，那么这时候Spring会使用CGLIB动态生成子类，重写抽象方法。(spring里面已经集成了)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个抽象方法，返回你要的原型 Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Task <span class="title function_">createTask</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> createTask(); <span class="comment">// 每次调用都返回新实例！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前任务ID: &quot;</span> + task.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ServiceA&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;task&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Task&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 关键：告诉 Spring，createTask() 方法要被动态实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;createTask&quot;</span> <span class="attr">bean</span>=<span class="string">&quot;task&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span> <span class="comment">// 标记这个方法应该返回一个原型 Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Task <span class="title function_">createTask</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> createTask(); <span class="comment">// 每次都是新的！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前任务ID: &quot;</span> + task.id<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h5><p>Bean定义相当于创建对象的配方，而 作用域 Scope 控制从改配方创建的对象实例的生命周期和可见范围。</p>
<p>作用域也是通过配置制定，无需在Java级别硬编码</p>
<p>Spring支持6种作用域</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>作用域</th>
<th>说明</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>singleton</code></td>
<td>（默认）每个 Spring IoC 容器中，Bean 定义对应唯一实例，所有请求共享此实例。</td>
<td>无状态 Bean（如工具类、DAO）</td>
</tr>
<tr>
<td><code>prototype</code></td>
<td>每次请求（注入或<code>getBean()</code>）都会创建新实例。</td>
<td>有状态 Bean（如用户会话相关对象）</td>
</tr>
<tr>
<td><code>request</code></td>
<td>每个 HTTP 请求对应一个实例，请求结束后销毁。</td>
<td>Web 应用，与单次请求相关的 Bean</td>
</tr>
<tr>
<td><code>session</code></td>
<td>每个 HTTP Session 对应一个实例，会话结束后销毁。</td>
<td>Web 应用，与用户会话相关的 Bean</td>
</tr>
<tr>
<td><code>application</code></td>
<td>绑定到 ServletContext 生命周期，整个 Web 应用共享一个实例。</td>
<td>Web 应用全局配置（类似 ServletContext）</td>
</tr>
<tr>
<td><code>websocket</code></td>
<td>绑定到 WebSocket 会话生命周期，适用于 STOMP 协议的 WebSocket 应用。</td>
<td>实时通信场景</td>
</tr>
</tbody>
</table>
</div>
<p>1、singleton作用域，Spring单例是 每个容器每个Bean，而饿汉式单例是每个类加载器。</p>
<p>singleton是根据缓存机制实现的，因为每次初始化的时候，会把实例存入到一个map里面后续所有的请求直接从缓存中直接获取，不用重复创建。</p>
<p>饿汉式单例，是java设计模式，通过类加载时直接初始化静态实例，保证每个jvm终只有一个实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 类加载时直接初始化，饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125; <span class="comment">// 私有构造器阻止外部创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、prototype 是每次请求创建新势力，容器仅负责实例化和配置，不管理后续生命周期</p>
<p>这个就容器仅负责实例化，依赖注入和初始化，不管理后续生命周期</p>
<p>3、Web相关作用域（request / session / application）</p>
<p>Web相关的Scope的Bean需要感知当前的HTTP请求 / 会话，但Spring容器本身运行在Servlet容器中，而HTTP请求是由Servlet容器（如Tomcat）的线程处理的。</p>
<p>要使用这些需要现在Web环境中注册 RequestContextListener 或 RequestContextFilter，确保HTTP请求与线程绑定。</p>
<ul>
<li>web.xml配置监听器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.request.RequestContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>或配置过滤器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后用注解配置</li>
</ul>
<p>@RequestScope、@SessionScope、@ApplicationScope分别对应三种Web作用域：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginAction</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><strong>后面还可以自定义Scope，但是由于太麻烦这里不做解释，用得少，后续要用可以看官方文档</strong></p>
<h4 id="Bean的继承"><a href="#Bean的继承" class="headerlink" title="Bean的继承"></a>Bean的继承</h4><p>Bean的继承允许子Bean继承父Bean定义的配置信息，仅需要覆盖或者补充差异部分，减少重复配置。但是Bean的继承是部分的继承不是全部继承，比如<strong>依赖是不会继承</strong>的，比如BeanA里面依赖了BeanB然后BeanC继承了BeanA，那么BeanC里面不会继承BeanB。然后scope的singleton也是不会继承的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>✅ <strong>可继承</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>scope</code></td>
<td>✅</td>
<td>包括 <code>singleton</code>、<code>prototype</code> 等</td>
</tr>
<tr>
<td>构造参数</td>
<td>✅</td>
<td><code>&lt;constructor-arg&gt;</code></td>
</tr>
<tr>
<td>属性值</td>
<td>✅</td>
<td><code>&lt;property&gt;</code></td>
</tr>
<tr>
<td>方法重写</td>
<td>✅</td>
<td><code>&lt;lookup-method&gt;</code></td>
</tr>
<tr>
<td>❌ <strong>不继承</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>depends-on</code></td>
<td>❌</td>
<td>子 Bean 必须显式声明依赖</td>
</tr>
<tr>
<td><code>lazy-init</code></td>
<td>❌</td>
<td>默认 <code>false</code>，需显式设置</td>
</tr>
<tr>
<td><code>autowire</code></td>
<td>❌</td>
<td>自动注入模式不继承</td>
</tr>
<tr>
<td><code>dependency-check</code></td>
<td>❌</td>
<td>已过时，但也不继承</td>
</tr>
<tr>
<td><code>init-method</code> / <code>destroy-method</code></td>
<td>❌</td>
<td>不继承，但可覆盖</td>
</tr>
<tr>
<td><code>factory-method</code></td>
<td>❌</td>
<td>不继承，但可覆盖</td>
</tr>
</tbody>
</table>
</div>
<p><strong>如果用xml方式声明 就用 parent属性指定父Bean</strong></p>
<p><strong>还有一些抽象Bean，通过abstract = “ture” 标记，抽象Bean无法通过getBean方法获取实例，也不能被其他Bean引用为依赖。容器实例化单例的时候会忽略抽象Bean</strong></p>
<h4 id="容器扩展点"><a href="#容器扩展点" class="headerlink" title="容器扩展点"></a>容器扩展点</h4><p>容器的扩展点是指实现特定的接口，对容器Bean的生命周期期间进行一些自定义干预的机制。</p>
<h5 id="BeanPostProcessor-接口"><a href="#BeanPostProcessor-接口" class="headerlink" title="BeanPostProcessor 接口"></a>BeanPostProcessor 接口</h5><p>这个是容器的扩展接口，定义了回调方法，作用于Bean实例，在容器完成Bean的实例化、依赖注入和初始化前后执行。</p>
<p>这个接口里面有两个核心的方法</p>
<p><strong>postProcessBeforeInitalization 方法</strong>：在Bean的初始化方法执行之前调用</p>
<p><strong>postProcessAfterInitialization方法</strong>：在Bean的初始化方法执行之后调用</p>
<p><strong>这个接口的使用范围是对所在的容器内的Bean生效</strong></p>
<p>执行顺序：多个BeanPostProcessor可以通过实现Ordered接口，设置order属性控制执行顺序，值越小越先执行，如果没实现，就会按注册顺序执行。</p>
<p><strong>与AOP自动代理的关系</strong></p>
<p>BeanPostProcessor实例及其直接引用的Bean不参与AOP自动代理（因为自动代理本身也是BeanPostProcessor，不过BeanPostProcessor启动阶段更早）</p>
<p>首先BeanPostProcessor和AOP都能对Bean进行增强，BeanPostProcessor一般用于容器启动过程中的早起干预</p>
<p>AOP一般用于Bean实例化完成之后，运用时调用方法时通过代理出发。</p>
<p><strong>注册方式</strong></p>
<ul>
<li>自动检测：ApplicationContext会自动扫描并注册配置中实现BeanPostProcessor接口的Bean，如果是用@Bean声明，返回类型需要明确为BeanPostProcessor或者其实现类。(如果<code>@Bean</code>方法的返回类型没有明确声明为<code>BeanPostProcessor</code>或其实现类，Spring 容器可能无法将其识别为<code>BeanPostProcessor</code>，从而当作普通 Bean 处理，导致其失去对其他 Bean 生命周期的干预能力。)</li>
<li>编程式注册：通过ConfigurableBeanFactory.addBeanPostProcessor方法手动注册，适用于条件逻辑或跨容器复制场景。这种注册不遵循Ordered接口，按注册顺序执行，且优先于自动检测的实例。</li>
</ul>
<h5 id="BeanFactoryPostProcessor接口"><a href="#BeanFactoryPostProcessor接口" class="headerlink" title="BeanFactoryPostProcessor接口"></a>BeanFactoryPostProcessor接口</h5><p>这个的核心作用是在容器实例化任何Bean之前，对Bean的配置元数据进行修改或者增强。比如修改类名、属性值、依赖关系、作用于、初始化方法等。这个是在初始化之前修改元数据，而BeanPostProcessor在初始化之前进行一些操作，而这个接口是初始化之前修改Bean</p>
<h5 id="FactoryBean接口"><a href="#FactoryBean接口" class="headerlink" title="FactoryBean接口"></a>FactoryBean接口</h5><p><strong>如果有很复杂的初始化逻辑，最好用java来表达，而不是用很长的xml来表达，你可以创建自己的FactoryBean，将复杂的初始化写到该类中，然后将Factory插入到容器中</strong></p>
<p>然后这个接口提供三个方法：</p>
<ul>
<li><code>T getObject()</code>: 返回本工厂创建的对象的一个实例。该实例可能会被共享，这取决于该工厂是返回singleton还是prototype。</li>
<li><code>boolean isSingleton()</code>: 如果这个 <code>FactoryBean</code> 返回 singleton，则返回 <code>true</code>，否则返回 <code>false</code>。这个方法的默认实现会返回 <code>true</code>。</li>
<li><code>Class&lt;?&gt; getObjectType()</code>: 返回由 <code>getObject()</code> 方法返回的对象类型，如果事先不知道类型，则返回 <code>null</code>。</li>
</ul>
<p><strong>获取实例的特殊规则</strong></p>
<ul>
<li>调用 <code>getBean(&quot;beanId&quot;)</code> 时，容器返回 <code>FactoryBean</code> 通过 <code>getObject()</code> 生成的<strong>目标对象</strong>。</li>
<li>若要获取 <code>FactoryBean</code> 自身实例，需在 ID 前加 <code>&amp;</code>，即 <code>getBean(&quot;&amp;beanId&quot;)</code>。</li>
</ul>
<p><strong>获取目标对象，是获得工厂的产物，获取自身实例是获取工厂</strong></p>
<h4 id="基于注解的容器配置"><a href="#基于注解的容器配置" class="headerlink" title="基于注解的容器配置"></a>基于注解的容器配置</h4><p><strong>在配置Spring时，注解是否比XML好？这个视情况而定，都可以</strong></p>
<p><strong>如果一个Bean的同一个属性即有注解又有xml那么最终会是xml中的配置</strong></p>
<h5 id="Autowired-按类型"><a href="#Autowired-按类型" class="headerlink" title="@Autowired 按类型"></a>@Autowired 按类型</h5><p><strong>注意：无论是 <code>@Autowired</code> 注入字段、setter 方法、普通方法还是构造函数，其最终效果都等价于在 XML 中配置 <code>&lt;bean&gt;</code> 及其依赖关系 —— 它们只是“声明依赖”的不同写法，底层目标一致：让 IoC 容器完成对象创建和依赖装配。</strong></p>
<p><strong>4种注入方式，这个可作用于构造函数、setter 方法、普通方法、字段</strong></p>
<p>这里理清一下：</p>
<ol>
<li>扫描所有 <code>&lt;bean&gt;</code> 标签 → 存入一个类似 <code>Map&lt;String, BeanDefinition&gt;</code> 的注册表。</li>
<li>遍历每个 BeanDefinition：<ul>
<li>使用反射 <code>Class.forName(&quot;...&quot;)</code> 加载类。</li>
<li>调用合适的构造函数（可能是无参也可能是有参）创建实例。</li>
<li>如果有 <code>&lt;property&gt;</code> 或 <code>&lt;constructor-arg&gt;</code>，就通过 setter 或构造函数传参进行依赖注入。</li>
</ul>
</li>
<li>最终把所有 Bean 放进容器（单例池），等待使用。</li>
</ol>
<p>在springboot框架中会有个service层然后有个impl层，这个构造函数的注入是写在impl层里面的，其效果就是跟在xml中写依赖的效果一样。</p>
<ol>
<li>扫描 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等注解类 → 注册为 BeanDefinition。</li>
<li>分析这些类的构造函数、字段、方法上的 <code>@Autowired</code>、<code>@Value</code> 等注解。</li>
<li>创建 Bean 实例时：<ul>
<li>若只有一个构造函数 → 直接调用它（传入匹配的 Bean 作为参数）</li>
<li>若多个构造函数且有 <code>@Autowired</code> → 选那个标注的</li>
<li>若没有构造函数注入 → 先用无参构造器创建对象，再对字段或 setter 注入</li>
</ul>
</li>
<li>最终完成依赖装配。</li>
</ol>
<p>所以才会有构造函数注入等4中注入方式。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注入方式</th>
<th>示例</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 构造函数注入</strong></td>
<td><code>public UserService(UserRepo repo)</code></td>
<td>推荐！不可变、强依赖、易测试</td>
</tr>
<tr>
<td><strong>2. Setter 注入</strong></td>
<td><code>@Autowired public void setUserRepo(...)</code></td>
<td>可选依赖，灵活性高，不推荐</td>
</tr>
<tr>
<td><strong>3. 字段注入</strong></td>
<td><code>@Autowired private UserRepo userRepo;</code></td>
<td>简洁但破坏封装，难以单元测试，<strong>已不推荐</strong></td>
</tr>
<tr>
<td><strong>4. 普通方法注入</strong></td>
<td><code>@Autowired public void init(Bean b) &#123; ... &#125;</code></td>
<td>少见，用于特殊逻辑</td>
</tr>
</tbody>
</table>
</div>
<h5 id="解决类型匹配不唯一问题"><a href="#解决类型匹配不唯一问题" class="headerlink" title="解决类型匹配不唯一问题"></a>解决类型匹配不唯一问题</h5><p><strong>1、@Primary  指定默认优先Bean</strong></p>
<p>当同一类型有多个 Bean 时，<code>@Primary</code>标记的 Bean 会成为 “默认首选”，无需额外指定名字，适合 “大部分场景用同一个 Bean” 的情况。</p>
<p>核心作用</p>
<ul>
<li>解决 “单值依赖（如单个字段、单个参数）的类型匹配冲突”：若按类型找到多个 Bean，自动选择带<code>@Primary</code>的 Bean。</li>
<li>优先级低于<code>@Qualifier</code>（<code>@Qualifier</code>更精准，<code>@Primary</code>是 “默认兜底”）。</li>
</ul>
<p>使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 标记为@Primary，成为默认首选</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">firstMovieCatalog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FirstMovieCatalog</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一类型的另一个Bean，无@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">secondMovieCatalog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecondMovieCatalog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入时自动选择firstMovieCatalog（因为带@Primary）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog; <span class="comment">// 实际是firstMovieCatalog</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、@Qualifier  精准按标识筛选Bean</strong></p>
<p>当需要更精细地选择依赖（比如同一类型有多个 Bean，且无明显 “默认首选”）时，<code>@Qualifier</code>通过 “自定义标识” 匹配 Bean，解决 “<code>@Primary</code>无法区分多个非默认 Bean” 的问题。</p>
<p><strong>核心作用：给Bean和注入添加统一标识，然后注入的时候用标识名注入，区别于按名称和按类型</strong></p>
<p>在使用@Qualifier的时候，用@Autowired注入的时候，会先按类型筛选Bean然后用@Qualifier从标识中选中唯一目标。</p>
<p><strong>3、@Genre 更加多功能标识注解</strong></p>
<p>@Qualifier是@Genre的父类，但是由于@Qualifier使用纯字符串标识的痛点，并且功能稀少的问题。</p>
<p>所以用@Genre注解，可以使用枚举参数防错（可以不用字符串防止拼错），多条件扩展（可以用多个标识来区分）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">MovieGenre</span> &#123; ACTION, COMEDY, DRAMA &#125;</span><br><span class="line"><span class="comment">// 1. 使用时直接选枚举，不会拼错</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Genre(MovieGenre.ACTION)</span> <span class="comment">// 编译时就有提示，不会拼错</span></span><br><span class="line"><span class="keyword">private</span> MovieCatalog actionCatalog;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 给Bean加多条件标识</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Genre(type = MovieGenre.ACTION, format = &quot;BLURAY&quot;)</span></span><br><span class="line"><span class="keyword">public</span> MovieCatalog <span class="title function_">actionBluRayCatalog</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActionMovieCatalog</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 注入时精准匹配多条件</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Genre(type = MovieGenre.ACTION, format = &quot;BLURAY&quot;)</span></span><br><span class="line"><span class="keyword">private</span> MovieCatalog actionBluRayCatalog;</span><br></pre></td></tr></table></figure>
<p><strong>4、利用泛型 作为隐含的限定符</strong></p>
<p>在Bean实现 泛型接口的时候，Spring会将泛型作为隐含的限定符，不需要额外加@Qualifier，可以通过泛型精准匹配依赖。</p>
<p>如果用@Autowired注入，会先按照接口类型筛选，然后再按照泛型类型进一步限定。</p>
<p>案例：</p>
<p>1、先配置泛型接口和实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Store</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类1：泛型为String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringStore</span> <span class="keyword">implements</span> <span class="title class_">Store</span>&lt;String&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 实现类2：泛型为Integer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerStore</span> <span class="keyword">implements</span> <span class="title class_">Store</span>&lt;Integer&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>2、配置Bean，利用注解配置xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StringStore <span class="title function_">stringStore</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringStore</span>(); &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IntegerStore <span class="title function_">integerStore</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IntegerStore</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、注入时通过泛型自动匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">// 泛型&lt;String&gt;匹配stringStore（Store&lt;String&gt;类型）</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Store&lt;String&gt; s1; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型&lt;Integer&gt;匹配integerStore（Store&lt;Integer&gt;类型）</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Store&lt;Integer&gt; s2; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入所有Store&lt;Integer&gt;类型的Bean（集合注入同样支持）</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Store&lt;Integer&gt;&gt; integerStores; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5、CustomAutowireConfigurer</strong></p>
<p>这个是Spring提供的一个BeanFactoryPostProcessor 实现类</p>
<p><strong>允许将未被 @Qualifier 注解标注的自定义注解 注册为合法的注入限定符</strong></p>
<p><strong>首先要了解自定义注解</strong></p>
<p>自定义注解是用@interface关键字声明的特殊接口，这个类似于给jvm添加配置，让jvm认得我们的自定义注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个自定义注解</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span> <span class="comment">// 注解可用于字段和参数</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 运行时保留，允许反射解析</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyQualifier &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; <span class="comment">// 注解的属性（类似方法定义，用于传递参数）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>@Target</code></strong>：指定注解能标注在什么地方（如类、字段、方法）。</li>
<li><strong><code>@Retention</code></strong>：指定注解的生命周期（<code>RUNTIME</code>表示运行时有效，Spring 注入时需要这个）。</li>
<li><strong>属性</strong>：像<code>value()</code>这样的 “抽象方法”，使用时可传值（如<code>@MyQualifier(&quot;user1&quot;)</code>）。</li>
</ul>
<p>那么我们现在使用自定义注解，然后如果我们想要自己的自定义注解在Spring自动注入中作为筛选标识，类似@Qualifier，就需要CustomAutowireConfigurer。</p>
<p>举例子：假设有多个DataSource类型的Bean（主库、从库、日志库），用自己的@DataSourceType标识</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义自定义注解：标记数据源类型</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DataSourceType &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; <span class="comment">// 可选值：&quot;master&quot;（主库）、&quot;slave&quot;（从库）、&quot;log&quot;（日志库）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后给Bean加标识也就是添加xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 新增：配置 CustomAutowireConfigurer，注册 @DataSourceType</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomAutowireConfigurer <span class="title function_">customAutowireConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CustomAutowireConfigurer</span> <span class="variable">configurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomAutowireConfigurer</span>();</span><br><span class="line">        Set&lt;String&gt; qualifierTypes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 传入 @DataSourceType 的全类名（需替换为你的实际包路径）</span></span><br><span class="line">        qualifierTypes.add(<span class="string">&quot;com.example.DataSourceType&quot;</span>);</span><br><span class="line">        configurer.setCustomQualifierTypes(qualifierTypes);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原有的数据源 Bean 定义不变</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@DataSourceType(&quot;master&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">masterDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 示例：返回主库数据源（如 HikariDataSource）</span></span><br><span class="line">        <span class="type">HikariDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">        ds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://master:3306/db&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@DataSourceType(&quot;slave&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">slaveDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HikariDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">        ds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://slave:3306/db&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后注入筛选</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 注入主库数据源</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@DataSourceType(&quot;master&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Resource-按名字"><a href="#Resource-按名字" class="headerlink" title="@Resource 按名字"></a>@Resource 按名字</h5><p>Spring支持在字段或者Bean属性设置方法上使用@Resource 进行注入。</p>
<p>@Resource 需要一个name属性，<strong>Spring将该值解释为要注入的Bean名称，如果没有明确指定名字，默认的名字来自于字段名或setter方法。如果是一个字段就采用字段名，如果是setter方法，则采用Bean的属性名。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line">    <span class="comment">// 未指定name，默认按字段名&quot;customerPreferenceDao&quot;匹配Bean</span></span><br><span class="line">    <span class="meta">@Resource</span> </span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>匹配逻辑：先找 <code>id</code> 为 <code>customerPreferenceDao</code> 的 Bean（名称匹配）；</li>
<li>兜底逻辑：若没找到同名 Bean，再找 <code>CustomerPreferenceDao</code> 类型的 Bean，且优先选带 <code>@Primary</code> 的（类型兜底）。</li>
</ul>
<p>当 <code>@Resource</code> 用在 setter 方法上且未指定 <code>name</code> 时，Spring 会从 setter 方法名中提取 “属性名” 作为默认 <code>name</code>（规则：去掉 <code>set</code> 前缀，首字母小写）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未指定name，从方法名setMovieFinder提取属性名&quot;movieFinder&quot;</span></span><br><span class="line">    <span class="meta">@Resource</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Value-属性注入"><a href="#Value-属性注入" class="headerlink" title="@Value 属性注入"></a>@Value 属性注入</h5><p>@Value主要用于将外部配置 如yml文件、系统属性、动态计算值 注入到Bean的字段或者构造函数参数中，是 <strong>Spring读取外部配置的核心注解</strong></p>
<p><strong>1、注入外部 properties 配置 最常用</strong></p>
<p>通过 <code>$&#123;配置键名&#125;</code> 语法读取外部 properties/yml 文件中的配置，需配合 <code>@PropertySource</code> 指定配置文件路径（Spring Boot 可省略，默认读取 <code>application.properties/yml</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 配置类：指定配置文件（非Spring Boot需加，Spring Boot可省略）</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span> <span class="comment">// 读取类路径下的配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 外部配置文件（application.properties）</span></span><br><span class="line">catalog.name=MovieCatalog</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 注入配置</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line">    <span class="comment">// 注入 catalog.name 对应的值（MovieCatalog）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String catalog;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(<span class="meta">@Value(&quot;$&#123;catalog.name&#125;&quot;)</span> String catalog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.catalog = catalog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、设置默认值</strong></p>
<p>通过 <code>$&#123;配置键名:默认值&#125;</code> 语法，当配置键不存在时，自动使用默认值（无需额外配置，Spring 原生支持）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line">    <span class="comment">// 若 catalog.name 不存在，使用默认值 &quot;defaultCatalog&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(<span class="meta">@Value(&quot;$&#123;catalog.name:defaultCatalog&#125;&quot;)</span> String catalog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.catalog = catalog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、自动类型转换</strong></p>
<p>Spring 内置 <code>ConversionService</code>，支持将配置文件中的 String 类型值自动转换为 <strong>基本类型（int、boolean 等）、数组、集合</strong> 等，无需手动转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 自动转换为 int（配置文件：max.movies=50）</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;max.movies&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxMovies;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 自动转换为 String 数组（配置文件：genres=Action,Comedy）</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;genres&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String[] genres;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、动态计算值 SpEL表达式</strong></p>
<p>通过 <code>#&#123;SpEL表达式&#125;</code> 语法支持动态计算，可读取系统属性、拼接字符串、创建复杂数据结构（Map、List 等），灵活性极高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 读取系统属性（user.name）并拼接字符串（如 &quot;adminCatalog&quot;）</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;user.name&#x27;] + &#x27;Catalog&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 动态创建 Map（无需外部配置，直接在注解中定义）</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#123;&#x27;Thriller&#x27;: 100, &#x27;Comedy&#x27;: 300&#125;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; movieCountMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="PostConstruct-和-PreDestory"><a href="#PostConstruct-和-PreDestory" class="headerlink" title="@PostConstruct 和 @PreDestory"></a>@PostConstruct 和 @PreDestory</h5><p><strong>首先明确 这两个是注解 不是类，他们的作用是标记方法，让Spring在特定的生命周期节点自动调用方法。</strong></p>
<p>1、@PostConstruct： Bean初始化完成后执行</p>
<p><strong>触发时机</strong> Bean 实例化（反射创建对象）、依赖注入（如 <code>@Autowired</code> 注入完成）之后，初始化方法（如 <code>@Bean(initMethod=&quot;xxx&quot;)</code>）执行之前。</p>
<p><strong>核心用途</strong> 执行Bean的初始化后准备工作，比如初始化缓存、加载配置等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingMovieLister</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Movie&gt; movieCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖注入（注入电影数据源）</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieDataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean初始化完成后，自动调用此方法填充缓存</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateMovieCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此时 dataSource 已注入，可安全使用</span></span><br><span class="line">        <span class="built_in">this</span>.movieCache = dataSource.loadAllMovies(); </span><br><span class="line">        System.out.println(<span class="string">&quot;缓存初始化完成，共加载&quot;</span> + movieCache.size() + <span class="string">&quot;部电影&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里加深一下理解，Spring容器给了很多个属性配置的时机，一个是通过反射创建对象，然后用依赖注入的时候，然后再到@PostConstruct，最后再是初始化，然后才会把Bean开始使用，这是spring容器的生命周期固定流程。</p>
<p>2、@PreDestory： Bean销毁前执行</p>
<p><strong>触发时机：</strong> Bean被销毁前 比如Spring容器关闭时，单例Bean会触发，原型Bean由JVM垃圾回收，不触发</p>
<p><strong>核心用途：</strong> 执行Bean的销毁前的清理工作，比如关闭连接、释放资源、清空缓存等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingMovieLister</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Movie&gt; movieCache;</span><br><span class="line">    <span class="keyword">private</span> Connection dbConnection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时建立数据库连接</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="built_in">this</span>.dbConnection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://xxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean销毁前，自动调用此方法释放资源</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearMovieCache</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 清空缓存</span></span><br><span class="line">        <span class="built_in">this</span>.movieCache.clear();</span><br><span class="line">        <span class="comment">// 关闭数据库连接（避免资源泄漏）</span></span><br><span class="line">        <span class="keyword">if</span> (dbConnection != <span class="literal">null</span> &amp;&amp; !dbConnection.isClosed()) &#123;</span><br><span class="line">            dbConnection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;资源清理完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置扫描和管理"><a href="#配置扫描和管理" class="headerlink" title="配置扫描和管理"></a>配置扫描和管理</h4><p>之前讲到很多Spring框架 对Bean的操作，比如属性注入，初始化等。</p>
<p><strong>这里将Spring框架如何扫描到标记以及如何配置</strong></p>
<h5 id="1、核心机制：Classpath扫描"><a href="#1、核心机制：Classpath扫描" class="headerlink" title="1、核心机制：Classpath扫描"></a><strong>1、核心机制：Classpath扫描</strong></h5><p>传统配置需要再xml中显式定义bean，而Classpath扫描允许Spring 自动扫描项目类路径下的特定类，将符合条件的类自动注册为容器中的Bean，无需手动编写Bean定义。</p>
<p>需要通过注解 @Component及其衍生注解 标记类。</p>
<p><strong>通过xml或者JavaConfig @ComponentScan开启扫描</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaConfig 开启扫描，扫描 com.example 包下的组件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Component注解及其衍生"><a href="#Component注解及其衍生" class="headerlink" title="@Component注解及其衍生"></a>@Component注解及其衍生</h5><div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>核心作用</th>
<th>适用层级 / 场景</th>
<th>特殊附加功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Component</code></td>
<td>通用组件标记，适用于所有 Spring 管理的类</td>
<td>无明确层级的通用组件</td>
<td>无特殊附加功能，仅作为扫描标记</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>标记 “数据访问层” 组件（如 DAO/Repository）</td>
<td>持久层（与数据库交互的类）</td>
<td>自动触发 “数据库异常翻译”（将 JDBC 异常转为 Spring 统一异常）</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>标记 “业务逻辑层” 组件</td>
<td>服务层（处理业务逻辑的类）</td>
<td>无特殊附加功能，但语义明确，便于代码分层和切面关联（如事务切面）</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td>标记 “表现层” 组件（如 Spring MVC 控制器）</td>
<td>控制层（接收请求、返回响应的类）</td>
<td>Spring MVC 自动识别为控制器，支持请求映射（如 <code>@RequestMapping</code>）</td>
</tr>
</tbody>
</table>
</div>
<h5 id="2、元注解和组合注解"><a href="#2、元注解和组合注解" class="headerlink" title="2、元注解和组合注解"></a>2、元注解和组合注解</h5><p>Spring中 <strong>元注解是注解的底层依赖</strong></p>
<p>元注解就是可以标注在其他注解上的注解，用于给目标注解赋予基础功能。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span>   <span class="comment">// 元注解：指定@Service可标注在类上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 元注解：指定@Service在运行时有效</span></span><br><span class="line"><span class="meta">@Documented</span>  <span class="comment">// 元注解：指定@Service会被javadoc文档记录</span></span><br><span class="line"><span class="meta">@Component</span>   <span class="comment">// 元注解：让@Service拥有@Component的“组件标记”功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>具体这些元注解就是spring框架已经帮我们实现好的标记，有特定的功能，就跟jdk一样已经帮我们实现好了，那么我们只需要记住常用的元注解即可</strong></p>
<p><strong>了解完元注解之后，我们可以自定义注解，整合多个元注解然后自定义注解或者使用spring提供的组合注解</strong></p>
<p>整合多个元注解：例如 Spring MVC 的 <code>@RestController</code> = <code>@Controller</code>（标记控制器）+ <code>@ResponseBody</code>（返回值直接转响应体），标注 <code>@RestController</code> 即可同时拥有两个注解的功能。</p>
<h5 id="扫描机制"><a href="#扫描机制" class="headerlink" title="扫描机制"></a>扫描机制</h5><p>上面提到了元注解， <strong>spring能通过组件扫描自动检测元注解类，无需手动定义Bean，跟之前@Bean自己全程手动控制Bean的生命周期不同。</strong></p>
<p>这里总结一下spring框架中两种核心的Bean注册方式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方式</th>
<th><code>@Component</code> + 扫描</th>
<th><code>@Bean</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>谁负责创建 Bean？</strong></td>
<td>类自己声明“我是组件”</td>
<td>配置类主动声明“我来提供这个 Bean”</td>
</tr>
<tr>
<td><strong>注册方式</strong></td>
<td>自动发现（被动）</td>
<td>主动定义（手动）</td>
</tr>
<tr>
<td><strong>控制权</strong></td>
<td>分散在各个类上</td>
<td>集中在配置类中</td>
</tr>
<tr>
<td><strong>适合对象类型</strong></td>
<td>自己写的业务类（Service, Repository 等）</td>
<td>第三方库的类或复杂初始化逻辑的对象</td>
</tr>
</tbody>
</table>
</div>
<p><strong>2中开启扫描的方式</strong></p>
<p>1、通过配置类制定扫描包</p>
<p>在 <code>@Configuration</code> 类上加 <code>@ComponentScan</code>，指定扫描的包（<code>basePackages</code> 属性，可简化为直接写包名）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;org.example&quot;)</span> <span class="comment">// 扫描org.example包及其子包下的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>2、通过xml配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3、扫描过滤"><a href="#3、扫描过滤" class="headerlink" title="3、扫描过滤"></a>3、扫描过滤</h5><p>上面讲到扫描机制是通过定义componentScan扫描元注解和定制xml定义扫描范围。</p>
<p>那么这里是通过 <strong>Filter</strong> 灵活修改扫描范围，排除或者过滤，或者突破默认扫描范围进行扩大。</p>
<p><strong>配置也是两种一种是xml，一种是通过componentScan的属性配置</strong></p>
<ul>
<li>JavaConfig：在 <code>@ComponentScan</code> 中通过 <code>includeFilters</code>（包含）、<code>excludeFilters</code>（排除）属性配置；</li>
<li>XML：在 <code>&lt;context:component-scan&gt;</code> 中通过 <code>&lt;context:include-filter&gt;</code>、<code>&lt;context:exclude-filter&gt;</code> 子标签配置。</li>
</ul>
<p><strong>Spring提供5种过滤类型FilterType</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Filter 类型（FilterType）</th>
<th>示例表达式</th>
<th>匹配逻辑（如何判断类是否符合规则）</th>
</tr>
</thead>
<tbody>
<tr>
<td>注解（ANNOTATION，默认）</td>
<td><code>org.springframework.stereotype.Repository</code></td>
<td>类上是否有指定注解（如排除所有带 <code>@Repository</code> 的类）</td>
</tr>
<tr>
<td>可指定（ASSIGNABLE_TYPE）</td>
<td><code>org.example.MovieFinder</code></td>
<td>类是否继承 / 实现了指定类 / 接口（如只包含实现 <code>MovieFinder</code> 的类）</td>
</tr>
<tr>
<td>AspectJ（ASPECTJ）</td>
<td><code>org.example..*Service+</code></td>
<td>类名是否匹配 AspectJ 表达式（如包含 <code>org.example</code> 包下所有以 <code>Service</code> 结尾的类）</td>
</tr>
<tr>
<td>正则（REGEX）</td>
<td><code>.*Stub.*Repository</code></td>
<td>类名是否匹配正则表达式（如包含类名含 <code>Stub</code> 且以 <code>Repository</code> 结尾的类）</td>
</tr>
<tr>
<td>自定义（CUSTOM）</td>
<td><code>org.example.MyTypeFilter</code></td>
<td>自定义 <code>TypeFilter</code> 实现类，按自定义逻辑判断（如按类的包路径 + 注解组合筛选）</td>
</tr>
</tbody>
</table>
</div>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    basePackages = &quot;org.example&quot;,</span></span><br><span class="line"><span class="meta">    includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;), // 正则匹配包含</span></span><br><span class="line"><span class="meta">    excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Repository.class) // 注解匹配排除</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在组件中定义Bean元数据"><a href="#在组件中定义Bean元数据" class="headerlink" title="在组件中定义Bean元数据"></a>在组件中定义Bean元数据</h5><p><strong>在普通 <code>@Component</code> 类中使用 <code>@Bean</code> 注解的场景</strong></p>
<p>首先@Component是标记一个类为组件，然后Spring扫描就会创建他的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Component 表示：我是一个需要被Spring管理的组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个类本身就是一个Bean，Spring会创建UserService实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusinessLogic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理用户业务逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring启动时：</span></span><br><span class="line"><span class="comment">// 1. 扫描到 @Component</span></span><br><span class="line"><span class="comment">// 2. 通过反射创建 UserService 实例</span></span><br><span class="line"><span class="comment">// 3. 放入容器，Bean名称默认为 &quot;userService&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>@Configuration 中 使用@Bean</strong></p>
<p>那么@Configura 是标记一个类为配置类，专门用于定义如何创建其他Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Configuration 表示：我是一个配置类，专门定义Bean的创建方式</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个类本身也是Bean，但主要作用是定义其他Bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义如何创建DataSource这个Bean</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义如何创建JdbcTemplate，并注入dataSource</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这里调用dataSource()会被Spring拦截，确保返回单例</span></span><br></pre></td></tr></table></figure>
<p><strong>那么@Component和@Configuration的区别是什么呢？</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对比维度</th>
<th><code>@Component</code></th>
<th><code>@Configuration</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>中文含义</td>
<td>组件</td>
<td>配置类</td>
</tr>
<tr>
<td>本质</td>
<td>被动注册：这个类自己就是一个 Bean</td>
<td>主动注册：这个类用来定义别的 Bean</td>
</tr>
<tr>
<td>使用位置</td>
<td>普通业务类上（Service, DAO 等）</td>
<td>配置类上（通常包含 <code>@Bean</code> 方法）</td>
</tr>
<tr>
<td>是否可包含 <code>@Bean</code> 方法</td>
<td>可以（但不推荐）</td>
<td>✅ 推荐且标准用法</td>
</tr>
<tr>
<td>内部方法调用是否走代理？</td>
<td>否</td>
<td>✅ 是（关键区别！）</td>
</tr>
<tr>
<td>底层实现</td>
<td>普通 Bean 实例化</td>
<td>CGLIB 动态代理增强</td>
</tr>
<tr>
<td>典型用途</td>
<td>业务逻辑组件</td>
<td>数据源、第三方库集成、自定义 Bean 创建</td>
</tr>
</tbody>
</table>
</div>
<p>举例：我们要创建两个 Bean：<code>dataSource</code> 和 <code>jdbcTemplate</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource()); <span class="comment">// ❌ 问题在这里！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题来了：<code>jdbcTemplate()</code> 方法里调用了 <code>dataSource()</code>，这会创建一个新的 <code>DataSource</code> 实例，而不是使用 Spring 容器中的那个！</p>
<p>为什么？因为 <code>@Component</code> 类没有被代理，方法调用就是普通 Java 方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource()); <span class="comment">// ✅ 正确：返回的是容器里的 Bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Spring 会通过 <strong>CGLIB 动态代理</strong> 创建 <code>DatabaseConfig</code> 的子类</li>
<li>所有 <code>@Bean</code> 方法都会被拦截</li>
<li>再次调用 <code>dataSource()</code> 时，会从容器中获取已存在的 Bean，而不是重新 new 一个</li>
</ul>
<p><strong><code>@Configuration</code> 的底层原理</strong></p>
<p>当 Spring 遇到 <code>@Configuration</code> 类时：</p>
<ol>
<li><p>使用 CGLIB 创建一个该类的子类代理</p>
</li>
<li><p>重写所有 <code>@Bean</code> 方法</p>
</li>
<li><p>在调用@Bean</p>
<p>方法时：</p>
<ul>
<li>先检查容器中是否有该 Bean</li>
<li>如果有 → 返回已有实例（单例）</li>
<li>如果没有 → 执行方法创建并注册到容器</li>
</ul>
</li>
</ol>
<p><strong>为什么用@Configuration或者@Component 而需要用@Bean</strong></p>
<p>1、使用第三方类为Bean</p>
<p>@Component类等注解需要直接标注在类上，如果使用 <strong>第三方库的类</strong> 只能通过@Bean 方法手动创建实例并注册到容器</p>
<p>2、需要定制Bean的创建逻辑</p>
<p>@Component 注册的Bean，实例化逻辑由类的构造函数决定，无法插入复杂的创建逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.profiles.active&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String profile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;dev&quot;</span>.equals(profile)) &#123;</span><br><span class="line">            <span class="comment">// 开发环境用H2内存库</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">H2DataSource</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 生产环境用MySQL</span></span><br><span class="line">            <span class="type">HikariDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">            ds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://xxx&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当需要利用组件的属性和方法的时候，可以将@Bean放到同一组件中也就是@Configuration中加@Bean这样就不用重复创建了</strong></p>
<h5 id="4、自动扫描组件和命名规则"><a href="#4、自动扫描组件和命名规则" class="headerlink" title="4、自动扫描组件和命名规则"></a>4、自动扫描组件和命名规则</h5><p><strong>Spring 自动扫描组件时如何给 Bean 命名 —— 默认按 “注解指定 name 或类名首字母小写” 生成，可通过自定义 <code>BeanNameGenerator</code> 改变规则，冲突时可用全类名命名，同时建议显式指定需被引用的 Bean 名称</strong>。</p>
<p>1、手动指定name</p>
<p>示例：<code>@Service(&quot;myMovieLister&quot;)</code> 标注的类，Bean 名称为 <code>myMovieLister</code>。</p>
<p>2、默认类名首字母小写</p>
<p>示例：<code>MovieFinderImpl</code> 类（无 <code>name</code> 指定），Bean 名称为 <code>movieFinderImpl</code>。</p>
<p>3、自定义命名策略</p>
<ul>
<li><p>JavaConfig：通过</p>
<p>@ComponentScan  nameGenerator</p>
<p>属性指定全类名；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>XML：通过 <code>&lt;context:component-scan&gt;</code> <code>name-generator</code></p>
<p>属性指定全类名；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span> <span class="attr">name-generator</span>=<span class="string">&quot;org.example.MyNameGenerator&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>4、使用全限定类名作为Bean名称</p>
<h5 id="自动扫描组件的作用域"><a href="#自动扫描组件的作用域" class="headerlink" title="自动扫描组件的作用域"></a>自动扫描组件的作用域</h5><p>自动扫描组件也需要声明他的生命周期</p>
<p><strong>自动扫描的组件默认是单例（singleton），可通过 <code>@Scope</code> 指定其他作用域；也可自定义作用域解析器；对于非单例作用域的 Bean，需配置作用域代理解决依赖注入问题，确保在不同作用域下正常使用</strong>。</p>
<p>1、那么如果是使用@Scope 注解 可以立刻指定该Bean的作用域，但是无法精细。</p>
<p>2、如果想要更加精细的操作，需要 自定义 <strong>作用域解析器</strong> 来决定Bean的作用域</p>
<ol>
<li><p>实现 <code>ScopeMetadataResolver</code> 接口（需提供无参构造函数），编写自定义作用域解析逻辑；</p>
</li>
<li><p>在扫描配置中指定该解析器：</p>
<ul>
<li><p>JavaConfig：通过<code>@ComponentScan</code> <code>scopeResolver</code> </p>
<p>属性指定全类名；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;, scopeResolver = MyScopeResolver.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>XML：通过 <code>&lt;context:component-scan&gt;</code> <code>scope-resolver</code></p>
<p>属性指定全类名；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span> <span class="attr">scope-resolver</span>=<span class="string">&quot;org.example.MyScopeResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>3、作用域代理 解决 不同作用域Bean的依赖冲突</p>
<p>当一个长生命周期的Bean 依赖一个段生命周期的Bean的时候，会导致注入失败。</p>
<p>那么这时候作用域代理的解决思路就是 <strong>注入代理对象而不是真实对象</strong>  作用域代理会生成一个 <strong>“代理对象” 注入到依赖方（如 <code>UserService</code>）</strong>，当依赖方调用代理对象的方法时，代理会 <strong>动态获取当前作用域的真实 Bean 实例</strong>，确保每次使用的都是 “有效实例”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="comment">// 单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRequestContext requestContext; <span class="comment">// 依赖请求域Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCurrentUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> requestContext.getUsername(); <span class="comment">// 问题：此处的requestContext可能已失效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上面的场景为例，给 <code>UserRequestContext</code> 配置作用域代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(</span></span><br><span class="line"><span class="meta">    value = &quot;request&quot;,</span></span><br><span class="line"><span class="meta">    proxyMode = ScopedProxyMode.INTERFACES // 生成基于接口的代理</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRequestContext</span> <span class="keyword">implements</span> <span class="title class_">RequestContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">// getter/setter...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 <code>UserService</code> 注入的是 <code>RequestContext</code> 接口的代理对象：</p>
<ul>
<li>当 <code>UserService</code> 调用 <code>requestContext.getUsername()</code> 时，代理会自动查找 “当前 HTTP 请求对应的 <code>UserRequestContext</code> 实例” 并调用其方法；</li>
<li>无论多少个请求，代理总能找到 “当前请求的有效实例”，解决了 “单例依赖短生命周期 Bean” 的冲突。</li>
</ul>
<h5 id="作用域代理的两种类型"><a href="#作用域代理的两种类型" class="headerlink" title="作用域代理的两种类型"></a>作用域代理的两种类型</h5><ul>
<li><strong><code>ScopedProxyMode.INTERFACES</code></strong>：基于 JDK 动态代理，要求被代理的 Bean 实现接口（如 <code>UserRequestContext</code> 实现 <code>RequestContext</code> 接口），代理对象实现相同接口。</li>
<li><strong><code>ScopedProxyMode.TARGET_CLASS</code></strong>：基于 CGLIB 代理，直接代理类（即使 Bean 没有实现接口），通过继承目标类生成代理对象。</li>
</ul>
<p>为什么直接注入会导致请求失效？</p>
<ol>
<li><p>当 Spring 容器启动时，UserService被初始化，此时会尝试注入</p>
<p>UserRequestContext</p>
<ul>
<li>但此时可能 <strong>没有任何 HTTP 请求正在处理</strong>（服务器刚启动，还没收到请求），<code>request</code> 作用域的 <code>UserRequestContext</code> 无法创建，可能注入 <code>null</code> 或抛出异常。</li>
</ul>
</li>
<li><p>即使容器启动后收到第一个请求，UserService注入的是 “第一个请求的UserRequestContext实例”。</p>
<ul>
<li>当第一个请求处理完毕后，这个 <code>UserRequestContext</code> 实例会被销毁（随请求失效）。</li>
</ul>
</li>
<li><p>当第二个请求到来时，UserService仍然持有 “已销毁的第一个请求的实例”，此时调用getUsername()会导致：</p>
<ul>
<li>访问已销毁的对象（可能抛出异常）；</li>
<li>即使没报错，获取到的也是第一个请求的数据（与当前请求无关，数据错误）。</li>
</ul>
</li>
</ol>
<p><strong>在每次调用方法时（如 <code>getUsername()</code>），动态查找当前正在处理的 HTTP 请求，并获取该请求绑定的 <code>UserRequestContext</code> 实例，再调用其方法</strong></p>
<p><strong>当前请求如何被代理感知</strong></p>
<p>代理能找到 “当前请求”，依赖于 <strong>ThreadLocal 机制</strong>：</p>
<ul>
<li>服务器处理 HTTP 请求时，会将当前 <code>HttpServletRequest</code> 对象存入 <code>ThreadLocal</code>（线程局部变量），确保同一处理线程中随时能获取到当前请求。</li>
<li>代理对象在调用方法时，会从 <code>ThreadLocal</code> 中取出 “当前请求”，再从请求中找到绑定的 <code>UserRequestContext</code> 实例（Spring 内部会将 <code>request</code> 作用域 Bean 与请求绑定并存储）。</li>
</ul>
<h3 id="资源-Resources"><a href="#资源-Resources" class="headerlink" title="资源 Resources"></a>资源 Resources</h3><p><strong>Resources 是 Spring 提供的一个抽象接口，用来统一访问“外部资源”——无论这些资源是来自 classpath、文件系统、URL 还是 JAR 包内部。</strong></p>
<p>以前读取一个配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 传统做法：容易出错，依赖具体路径</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;config/app.properties&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br></pre></td></tr></table></figure>
<p>现在spring框架统一了访问api</p>
<h4 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h4><p>位于 <code>org.springframework.core.io.</code> 包中的Spring <code>Resource</code> 接口，旨在成为一个更有能力的接口，用于抽象访问低级资源。下面的列表提供了 <code>Resource</code> 接口的概述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resource</span> <span class="keyword">extends</span> <span class="title class_">InputStreamSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    URL <span class="title function_">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    URI <span class="title function_">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    File <span class="title function_">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    ReadableByteChannel <span class="title function_">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    Resource <span class="title function_">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getFilename</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Resource</code> 接口中最重要的一些方法是。</p>
<ul>
<li><code>getInputStream()</code>: 定位并打开资源，返回一个用于读取资源的 <code>InputStream</code>。我们期望每次调用都能返回一个新的 <code>InputStream</code>。关闭该流是调用者的责任。</li>
<li><code>exists()</code>: 返回一个 <code>boolean</code> 值，表示该资源是否以物理形式实际存在。</li>
<li><code>isOpen()</code>: 返回一个 <code>boolean</code>，表示该资源是否代表一个具有开放流的句柄。如果为 <code>true</code>，<code>InputStream</code> 不能被多次读取，必须只读一次，然后关闭以避免资源泄漏。对于所有通常的资源实现，除了 <code>InputStreamResource</code> 之外，返回 <code>false</code>。</li>
<li><code>getDescription()</code>: 返回该资源的描述，用于处理该资源时的错误输出。这通常是全路径的文件名或资源的实际URL。</li>
</ul>
<h4 id="内置的Resource实现"><a href="#内置的Resource实现" class="headerlink" title="内置的Resource实现"></a>内置的Resource实现</h4><p>Spring包括几个内置的 <code>Resource</code> 实现。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://springdoc.cn/spring/core.html#resources-implementations-urlresource"><code>UrlResource</code></a></li>
<li><a target="_blank" rel="noopener" href="https://springdoc.cn/spring/core.html#resources-implementations-classpathresource"><code>ClassPathResource</code></a></li>
<li><a target="_blank" rel="noopener" href="https://springdoc.cn/spring/core.html#resources-implementations-filesystemresource"><code>FileSystemResource</code></a></li>
<li><a target="_blank" rel="noopener" href="https://springdoc.cn/spring/core.html#resources-implementations-pathresource"><code>PathResource</code></a></li>
<li><a target="_blank" rel="noopener" href="https://springdoc.cn/spring/core.html#resources-implementations-servletcontextresource"><code>ServletContextResource</code></a></li>
<li><a target="_blank" rel="noopener" href="https://springdoc.cn/spring/core.html#resources-implementations-inputstreamresource"><code>InputStreamResource</code></a></li>
<li><a target="_blank" rel="noopener" href="https://springdoc.cn/spring/core.html#resources-implementations-bytearrayresource"><code>ByteArrayResource</code></a></li>
</ul>
<p>这里是spring内置的一些读取资源的类，spring中还内置了很多数据验证，类型转换等的类，需要用的用的多就记住了，这里就不列出来了</p>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p><strong>动态代理是 “工具”，Spring AOP 是 “用这个工具解决问题的完整方案”</strong></p>
<p>回顾一下动态代理：jdk动态代理流程就是首先规定一个共同的接口，然后实现一个实现类实现接口写好核心业务，然后写自定义的MyInvocationHandler代理类实现InvocationHandler接口，然后在里面通过invoke方法然后在里面调用核心业务并且在核心业务前或后写增强代码，然后在写个代理生成工厂，用于动态生成刚刚的动态代理，然后这个代理工厂就用Proxy的newInstance方法生成代理类，然后传入代理类的类加载器和实现的接口还有拦截器就是刚刚的InvocationHandler就可以动态生成代理类了。然后使用的时候就新建目标对象，然后用代理工厂创建目标对象的代理对象，然后调用的时候用代理对象的方法就能实现增强方法了。</p>
<p>本章讨论了基于 schema 和 <code>@AspectJ</code> 的AOP支持。也就是包装了动态代理的功能了。</p>
<h4 id="AOP中的各种新概念"><a href="#AOP中的各种新概念" class="headerlink" title="AOP中的各种新概念"></a>AOP中的各种新概念</h4><p>那么Spring AOP怎么使用呢？需要先了解一下一些新的定义。</p>
<ul>
<li>Aspect 切面：这个就是类似于增强类，只要给普通类@Aspect注解就能把这个类当成切面类，里面写各种增强的逻辑，进行模块化管理，这个类里面写的全是增强的逻辑。</li>
<li>Join point 连接点：就是可以被拦截的地方，也就是核心业务逻辑的地方。</li>
<li>Advice 通知：你写的增强逻辑的代码。</li>
<li>Pointcut 切入点：就是筛选逻辑，用来告诉spring那些地方用上增强逻辑，写在切面类中，他是一个普通方法，但是用@Pointcut注解标记，方法体一般为空，只起 命名+定义规则的作用</li>
<li>Introduction 引入：<strong>让你能在不改源码的情况下，让一个对象“假装”实现了某个新接口，并拥有对应的方法和状态。</strong>引入使用的是cglib动态代理。</li>
<li>Advisor = Pointcut + Advice 通知器 Spring aop 中整整被应用代理上的单元是Advisor</li>
</ul>
<p><strong>看到这里会有疑惑，那么引入和通知有什么区别，有通知不就好了，引入不也是增强方法吗？</strong></p>
<p>这里还是有区别的，如果是通知，调用方是感知不到增强的只是被动的增强，比如日志增强，只是调用的时候被动的记录了日志，调用放感知不到还有日志这个功能。但是引入是扩展了接口方法，假设利用引入增强，那么调用方可以调用新方法，直接帮我们包装了动态代理，只需要配置好新接口和实现就能通过@DeclareParents 直接实现cglib动态代理。</p>
<ul>
<li>Target Object 目标对象：被代理对象</li>
<li>AOP proxy AOP代理：AOP框架中实现的代理对象</li>
<li>Weaving 织入：首先只是一个概念不是方法，把切面逻辑 编织 进目标对象的执行流程中，生成一个能自动触发增强行为的代理对象。发生的时机是Spring容器创建Bean的过程中，在BeanPostProcessor阶段，自动生成代理对象，已经帮我们封装好了。</li>
</ul>
<h4 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h4><ul>
<li>前置通知 Before advice：在连接点前执行，无法阻止连接点执行</li>
<li><p>返回后通知 After returning advice：在连接点无异常抛出后执行</p>
</li>
<li><p>最终通知 After finally advice：无论连接点正常或者异常退出都会执行</p>
</li>
<li>环绕通知 Around advice：可在连接点前后执行操作，还能决定是否自行连接点，或者自定义返回值，抛出异常。</li>
</ul>
<h4 id="AOP实践"><a href="#AOP实践" class="headerlink" title="AOP实践"></a>AOP实践</h4><h5 id="启用-AspectJ配置"><a href="#启用-AspectJ配置" class="headerlink" title="启用@AspectJ配置"></a>启用@AspectJ配置</h5><p>要用Java <code>@Configuration</code> 启用 <code>@AspectJ</code> 支持，请添加 <code>@EnableAspectJAutoProxy</code> 注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="声明一个Aspect"><a href="#声明一个Aspect" class="headerlink" title="声明一个Aspect"></a>声明一个Aspect</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 标识为切面类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 让Spring管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotVeryUsefulAspect</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="声明切点"><a href="#声明切点" class="headerlink" title="声明切点"></a>声明切点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问修饰符（可选） void 切点名称() &#123; &#125;</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;切点表达式&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 切点名称() &#123;&#125; <span class="comment">// 方法体必须为空</span></span><br></pre></td></tr></table></figure>
<p>核心是「指定器 + 匹配规则」</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问修饰符（可选） void 切点名称() &#123; &#125;</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;切点表达式&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 切点名称() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果是复用切点就这么写就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合2个切点：service层的public方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;publicMethod() &amp;&amp; inServiceLayer()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">servicePublicMethod</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用其他切面的切点（全类名+方法名）</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;com.xyz.CommonPointcuts.businessService()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">referOtherPointcut</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>切点表达式</strong></p>
<p>在AOP支持的指定器中，<strong>excution是核心</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execution(</span><br><span class="line">    访问修饰符?  // 如public、private，可选，*表示任意</span><br><span class="line">    返回值类型   // 必须写，*表示任意返回值，全类名表示特定类型（如java.lang.String）</span><br><span class="line">    类路径?      // 可选，如com.xyz.service.*，表示该类下的方法</span><br><span class="line">    方法名(参数模式)  // 必须写，方法名支持*通配符，参数模式有固定写法</span><br><span class="line">    异常类型?    // 可选，如throws java.lang.Exception，匹配抛出该异常的方法</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>常用指定器</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>需求</th>
<th>切点表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>所有 public 方法</td>
<td><code>execution(public * *(..))</code></td>
</tr>
<tr>
<td>所有名称以 set 开头的方法</td>
<td><code>execution(* set*(..))</code></td>
</tr>
<tr>
<td>AccountService 接口的所有方法</td>
<td><code>execution(* com.xyz.service.AccountService.*(..))</code></td>
</tr>
<tr>
<td>service 包下的所有方法</td>
<td><code>execution(* com.xyz.service.*.*(..))</code></td>
</tr>
<tr>
<td>service 包及子包下的所有方法</td>
<td><code>execution(* com.xyz.service..*.*(..))</code>（<code>..</code>表示子包）</td>
</tr>
<tr>
<td>service 包下返回 String 的 public 方法</td>
<td><code>execution(public String com.xyz.service.*.*(..))</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>辅助指定器</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指定器</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>within</td>
<td>匹配指定包 / 类下的方法</td>
<td><code>within(com.xyz.service..*)</code>（service 包及子包）</td>
</tr>
<tr>
<td>bean</td>
<td>匹配指定名称的 Spring Bean 的方法</td>
<td><code>bean(tradeService)</code>（Bean 名为 tradeService）、<code>bean(*Service)</code>（通配符，匹配所有后缀为 Service 的 Bean）</td>
</tr>
<tr>
<td>@annotation</td>
<td>匹配带有指定注解的方法</td>
<td><code>@annotation(org.springframework.transaction.annotation.Transactional)</code>（匹配带 @Transactional 的方法）</td>
</tr>
<tr>
<td>@within</td>
<td>匹配所在类带有指定注解的方法</td>
<td><code>@within(com.xyz.annotation.Log)</code>（类上有 @Log 注解的所有方法）</td>
</tr>
<tr>
<td>target</td>
<td>匹配目标对象（被代理类）是指定类型的方法</td>
<td><code>target(com.xyz.service.UserService)</code>（目标对象实现 UserService 接口）</td>
</tr>
</tbody>
</table>
</div>
<h5 id="声明Advice"><a href="#声明Advice" class="headerlink" title="声明Advice"></a>声明Advice</h5><p>切面中定义的增强逻辑代码，会在匹配的连接点 执行时被触发。</p>
<p>它必须与一个 切点表达式关联，决定在哪些方法上生效。</p>
<p>切点可以是：直接写在Advice里面通过@Before等注解然后在里面写切点的匹配条件（内联切点）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.xyz.dao.*.*(..))&quot;)</span></span><br></pre></td></tr></table></figure>
<p>或者通过引用命名切点，先用一个方法定义好切点匹配逻辑然后再另一个方法引用切点方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.xyz.dao.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataAccessOperation</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(&quot;dataAccessOperation()&quot;)</span></span><br></pre></td></tr></table></figure>
<p><strong>五种Advice类型以及命名方式</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>注解</th>
<th>触发时机</th>
<th>典型用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Before</strong></td>
<td><code>@Before</code></td>
<td>方法执行<strong>之前</strong></td>
<td>权限检查、日志记录</td>
</tr>
<tr>
<td><strong>After Returning</strong></td>
<td><code>@AfterReturning</code></td>
<td>方法<strong>正常返回后</strong></td>
<td>处理返回值、缓存结果</td>
</tr>
<tr>
<td><strong>After Throwing</strong></td>
<td><code>@AfterThrowing</code></td>
<td>方法<strong>抛出异常后</strong></td>
<td>异常恢复、日志记录</td>
</tr>
<tr>
<td><strong>After (Finally)</strong></td>
<td><code>@After</code></td>
<td>方法<strong>无论正常或异常退出后</strong>（类似 finally）</td>
<td>资源释放（锁、连接）</td>
</tr>
<tr>
<td><strong>Around</strong></td>
<td><code>@Around</code></td>
<td><strong>环绕</strong>整个方法执行</td>
<td>性能监控、事务控制、缓存</td>
</tr>
</tbody>
</table>
</div>
<p><strong>参数绑定！</strong></p>
<p>没有参数绑定的话，Advice 只能做 “无差别增强”（比如不管目标方法是什么、传了什么参数，都只打印固定日志）；但实际开发中，增强逻辑往往需要 “针对性处理”，必须依赖目标方法的具体信息。</p>
<p> 1、绑定返回值（<code>@AfterReturning</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">    pointcut = &quot;execution(* service.*(..))&quot;,</span></span><br><span class="line"><span class="meta">    returning = &quot;result&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logResult</span><span class="params">(Object result)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>returning</code> 的值必须与方法参数名一致。</li>
<li>自动限制只匹配返回 <code>Object</code>（或指定类型）的方法。</li>
</ul>
<p>2、绑定异常（<code>@AfterThrowing</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">    pointcut = &quot;execution(* service.*(..))&quot;,</span></span><br><span class="line"><span class="meta">    throwing = &quot;ex&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleException</span><span class="params">(DataAccessException ex)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只匹配抛出 <code>DataAccessException</code> 或其子类的方法。</li>
</ul>
<p>3、绑定方法参数（<code>args</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* dao.*(..)) &amp;&amp; args(account, ..)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Account account)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>匹配第一个参数为 <code>Account</code> 的方法，并将实际对象传入。</li>
</ul>
<p>4、绑定注解（<code>@annotation</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;@annotation(auditable)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">audit</span><span class="params">(Auditable auditable)</span> &#123;</span><br><span class="line">    <span class="type">AuditCode</span> <span class="variable">code</span> <span class="operator">=</span> auditable.value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、访问 JoinPoint 上下文</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;...&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(JoinPoint jp)</span> &#123;</span><br><span class="line">    Object[] args = jp.getArgs();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> jp.getTarget();</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> jp.getSignature().getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@Around</code> 必须使用 <code>ProceedingJoinPoint</code>。</li>
</ul>
<p><strong>Around Advice额外说明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* service.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">profile</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed(); <span class="comment">// ⚠️ 必须调用 proceed() 才会执行原方法</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;Time: &quot;</span> + (end - start));</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回给调用者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>必须返回 <code>Object</code></strong>，即使原方法是 <code>void</code>。</li>
<li><code>proceed()</code> 可以调用 0 次、1 次或多 次（但通常只调 1 次）。</li>
<li>可传新参数：<code>pjp.proceed(new Object[]&#123;newArg&#125;)</code>。</li>
</ul>
<p><strong>同一个切面内，执行顺序</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Around → @Before → 方法执行 → @AfterReturning / @AfterThrowing → @After</span><br></pre></td></tr></table></figure>
<p><strong>除了JoinPoint都需要显示指定参数名进行匹配</strong></p>
<p><code>JoinPoint</code> 接口提供了许多有用的方法。</p>
<ul>
<li><code>getArgs()</code>: 返回方法的参数。</li>
<li><code>getThis()</code>: 返回代理对象。</li>
<li><code>getTarget()</code>: 返回目标对象。</li>
<li><code>getSignature()</code>: 返回正在被 advice 的方法的描述。</li>
<li><code>toString()</code>: 打印对所 advice 的方法的有用描述。</li>
</ul>
<h5 id="Introduction引入"><a href="#Introduction引入" class="headerlink" title="Introduction引入"></a>Introduction引入</h5><ul>
<li><strong>Introduction</strong> 允许一个切面<strong>动态地为目标类添加新的接口和实现</strong>，即使这些类在源码中并没有实现该接口。</li>
<li>在 Spring AOP 中通过 <code>@DeclareParents</code> 注解实现。</li>
</ul>
<p><strong>效果</strong>：目标对象在运行时“看起来”像是实现了某个新接口，并具备其实现逻辑。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组成部分</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>@DeclareParents</code></strong></td>
<td>用于声明引入的注解</td>
</tr>
<tr>
<td><strong><code>value</code> 属性</strong></td>
<td>AspectJ 类型匹配表达式，指定哪些类要被增强（如 <code>&quot;com.xyz.service.*+&quot;</code> 表示 service 包下所有类及其子类）</td>
</tr>
<tr>
<td><strong>字段类型</strong></td>
<td>要引入的<strong>接口类型</strong>（如 <code>UsageTracked</code>）</td>
</tr>
<tr>
<td><strong><code>defaultImpl</code> 属性</strong></td>
<td>提供该接口的<strong>默认实现类</strong>（如 <code>DefaultUsageTracked.class</code>）</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsageTracking</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引入声明：所有 service 实现类都“实现” UsageTracked 接口</span></span><br><span class="line">    <span class="meta">@DeclareParents(</span></span><br><span class="line"><span class="meta">        value = &quot;com.xyz.service.*+&quot;, </span></span><br><span class="line"><span class="meta">        defaultImpl = DefaultUsageTracked.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UsageTracked mixin; <span class="comment">// 字段类型 = 要引入的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用引入的接口</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.xyz..service.*.*(..)) &amp;&amp; this(usageTracked)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordUsage</span><span class="params">(UsageTracked usageTracked)</span> &#123;</span><br><span class="line">        usageTracked.incrementUseCount(); <span class="comment">// 调用新增的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Aspect实例化模式</strong></p>
<p><em>为什么需要非单例切面？*</em></p>
<p>单例切面的问题：<strong>切面实例是共享的，无法存储「专属某个目标对象 / 代理对象」的状态</strong>。比如想统计「每个服务 Bean 的方法调用次数」—— 如果用单例切面，计数器是全局共享的，无法区分是哪个服务 Bean 的调用；而非单例切面（perthis/pertarget）能为每个服务 Bean 创建专属实例，计数器可以独立存储，互不干扰。</p>
<p>每个切面在Spring容器中默认只有一个实例，如果想要非单例模型切面也是可以支持的这里有两个模型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong><code>perthis(pointcut)</code></strong></th>
<th>为<strong>每个唯一的代理对象（<code>this</code>）</strong>创建一个切面实例。 → 当某个服务 Bean 首次被调用时，为其创建专属切面实例。</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>pertarget(pointcut)</code></strong></td>
<td>为<strong>每个唯一的目标对象（<code>target</code>）</strong>创建一个切面实例。 → 与 <code>perthis</code> 类似，但在 CGLIB 代理下可能表现不同（<code>this</code> 是代理，<code>target</code> 是原始对象）。</td>
</tr>
</tbody>
</table>
</div>
<p>大多数场景下（比如 JDK 动态代理，目标对象实现接口），一个目标对象对应一个代理对象，<code>perthis</code> 和 <code>pertarget</code> 效果一致；但在 CGLIB 代理（目标对象无接口）或特殊代理场景下，可能出现 “多个代理对象对应同一个目标对象”（罕见），此时两者会有差异。</p>
<p>这时候perthis会有多个，pertarget只有一个。</p>
<p>那么这时候就能用计数器来计数或者在逻辑代码里面实现自己想要的特定功能了，比如每个目标Bean的引用次数</p>
<p><strong>使用方式</strong></p>
<p>切面类加<code>@Scope(&quot;perthis(切点)&quot;)</code>或<code>@Scope(&quot;pertarget(切点)&quot;)</code>，配合<code>@Aspect</code>和<code>@Component</code>即可。</p>
<p><strong>Spring AOP 默认根据目标对象是否有接口选择 JDK 代理或 CGLIB 代理；通过设置 proxy-target-class=”true” 可强制使用 CGLIB，从而代理类的所有非 final 方法，但需注意 final 方法无法被增强。</strong></p>
<h5 id="可能会出现的问题"><a href="#可能会出现的问题" class="headerlink" title="可能会出现的问题"></a>可能会出现的问题</h5><p>首先String aop不能代理final方法，也就是说final方法无法被增强。</p>
<p>自调用问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplePojo</span> <span class="keyword">implements</span> <span class="title class_">Pojo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bar(); <span class="comment">// ← 这是“自调用”</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个SimplePojo被代理了，然后这个foo方法调用的是this方法，这时候没用走代理对象的方法而是调用对象内部的方法，这样就不会触发增强方法，导致Advice不执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        serviceB.bar(); <span class="comment">// ← 跨 Bean 调用，走代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123; ... &#125; <span class="comment">// ← Advice 生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>首先这个是Spring框架的一个IOC容器，主要是将对象创建、依赖注入、生命周期交给Spring容器，里面有几个关键组件一个是BeanFactory基础的IOC容器，ApplicationContext高级的容器支持AOP、事件、国际化等，BeanDefinition描述Bean的元数据。</p>
<p><strong>Spring容器启动流程</strong></p>
<p>分为三个阶段，准备阶段，Bean处理阶段，完成阶段。</p>
<p>准备阶段，首先加载配置文件，读取XML、JavaConfig等配置，获取数据库连接，AOP等配置类信息，然后创建容器生成ApplicationContext，初始化BeanFactory，然后解析Bean定义，解析BeanDefinitions，提取Bean的元数据</p>
<p>Bean处理阶段，然后就实例化Bean，根据BeanDefinitions创建Bean对象，然后依赖注入属性，通过构造器或者属性注入Bean依赖，然后管理生命周期，调用初始化方法如InitializingBean.afterPropertiesSet，然后执行后处理器，利用BeanPostProcessor增强Bean生成AOP代理。</p>
<p>完成阶段，发布事件，发送容器启动等事件。然后完成启动了。</p>
<p><strong>Web 项目如何加载 Spring XML</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── main/</span><br><span class="line">│   ├── java/</span><br><span class="line">│   └── resources/</span><br><span class="line">│       ├── applicationContext.xml      ← 根上下文</span><br><span class="line">│       └── spring-mvc.xml             ← MVC 上下文</span><br><span class="line">└── webapp/</span><br><span class="line">    └── WEB-INF/</span><br><span class="line">        └── web.xml</span><br></pre></td></tr></table></figure>
<p>可以理解为spring的配置文件都放在resource文件夹下，然后web项目需要配置服务器加载的配置文件位置通过配置DispathcherServlet可以读取加载resouces文件夹下的配置文件,在非SpringBoot项目这些都需要手动配置。</p>
<p>虽然 XML 配置仍在使用，但现代 Spring Boot 项目更常用：</p>
<ul>
<li><strong>Java Config</strong>：用 <code>@Configuration</code> 类替代 XML</li>
<li><strong>自动配置</strong>：Spring Boot 自动配置 DataSource、MVC 等，无需手动写 bean</li>
<li><strong>application.properties/yml</strong>：外部化配置</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在Spring中如何让测试更容易。</p>
<p>Spring提倡测试驱动开发，也就是先通过所有测试用例然后再优化重构开发。</p>
<h3 id="测试的重要概念"><a href="#测试的重要概念" class="headerlink" title="测试的重要概念"></a>测试的重要概念</h3><p><strong>1、核心概念</strong></p>
<p>首先Spring测试支持单元测试和集成测试。</p>
<p><strong>单元测试</strong>：主要目的是不启动容器，隔离依赖，spring通过提供Mock对象和工具类来提供单元测试的环境。</p>
<p>隔离的目的，比如测试UserService，但是这个依赖UserDao，然后把这个依赖换成一个假的可控制的替代者，让测试只关注UserService本身的逻辑，不受外部依赖影响。</p>
<p>Stub是桩，简单的假对象，只返回固定结果，硬编码模拟依赖的行为</p>
<p>Mock是模拟，更灵活的假对象，比如指定调用册数，参数匹配等。</p>
<p>正是因为IoC 是依赖注入，而不是Service自己New对象，我们才能轻松替换依赖。由于UserDao是通过构造器或者Setter注入的，测试时可以直接传入Mock或者Stub对象，替代真实的Dao</p>
<p><strong>集成测试</strong>：启动部分/完成的容器，验证组件能否正常协作，提供@SpringBootTest，@DataJpaTest，MocMvc等来支持。</p>
<p><strong>支持的组件</strong></p>
<p><strong>Mock对象用于单元测试</strong></p>
<ul>
<li><code>MockEnvironment / MockPropertySource</code>模拟配置环境</li>
<li><code>MockHttpServletRequest / MockHttpSession</code> 模拟Web请求</li>
<li><code>MockServerHttpRequest</code> 用于响应式测试</li>
</ul>
<p><strong>测试工具类</strong></p>
<ul>
<li><code>ReflectionTestUtils</code>：反射操作私有字段/方法</li>
<li><code>AopTestUtils</code>：获取AOP代理背后的原始对象</li>
<li><code>ModelAndViewAssert</code> ：断言MVC控制器返回结果</li>
</ul>
<p><strong>集成测试框架</strong></p>
<ul>
<li><strong>Servlet Stack</strong>：<code>MockMvc</code>（基于 Mock Servlet API，无需部署）</li>
<li><strong>Reactive Stack</strong>：<code>WebTestClient</code>（支持无服务器或端到端测试）</li>
</ul>
<h3 id="如何使用Spring进行测试"><a href="#如何使用Spring进行测试" class="headerlink" title="如何使用Spring进行测试"></a>如何使用Spring进行测试</h3><p>1、单元测试 不依赖Spring容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接 new + Mock 依赖</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUserService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Mock 依赖</span></span><br><span class="line">    <span class="type">OrderRepository</span> <span class="variable">mockRepo</span> <span class="operator">=</span> Mockito.mock(OrderRepository.class);</span><br><span class="line">    <span class="keyword">when</span>(mockRepo.count()).thenReturn(<span class="number">5L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 手动组装被测对象</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">    ReflectionTestUtils.setField(service, <span class="string">&quot;orderRepository&quot;</span>, mockRepo); <span class="comment">// 注入私有字段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 调用并断言</span></span><br><span class="line">    assertEquals(<span class="number">5L</span>, service.getOrderCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、集成测试</p>
<ul>
<li><strong>完整上下文测试</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceIntegrationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 由 Spring 注入完整依赖链</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testWithRealDependencies</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 可能使用内存数据库（如 H2）</span></span><br><span class="line">        assertNotNull(userService.createUser(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="切片测试（只加载必要组件）"><a href="#切片测试（只加载必要组件）" class="headerlink" title="切片测试（只加载必要组件）"></a>切片测试（只加载必要组件）</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span> <span class="comment">// 仅加载 JPA 相关 Bean</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepositoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestEntityManager em;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">findByEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;alice@example.com&quot;</span>);</span><br><span class="line">        em.persistAndFlush(user);</span><br><span class="line"></span><br><span class="line">        Optional&lt;User&gt; found = repository.findByEmail(<span class="string">&quot;alice@example.com&quot;</span>);</span><br><span class="line">        assertTrue(found.isPresent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="Web-层测试（MockMvc）"><a href="#Web-层测试（MockMvc）" class="headerlink" title="Web 层测试（MockMvc）"></a>Web 层测试（MockMvc）</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserController.class)</span> <span class="comment">// 仅加载 Web 层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 用 Mock 替代真实 Service</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shouldReturnUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">when</span>(userService.findById(<span class="number">1L</span>)).thenReturn(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/users/1&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(jsonPath(<span class="string">&quot;$.name&quot;</span>).value(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>案例：用 TDD（测试驱动开发）开发一个用户注册功能</p>
<p>🎯 需求</p>
<ul>
<li>用户注册时，邮箱不能重复</li>
<li>成功注册返回用户 ID</li>
</ul>
<hr>
<p>步骤 1：先写测试（红）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserControllerTest.java</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserController.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerUser_withDuplicateEmail_returns409</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> <span class="string">&quot;exist@example.com&quot;</span>;</span><br><span class="line">        <span class="keyword">when</span>(userService.isEmailExists(email)).thenReturn(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When &amp; Then</span></span><br><span class="line">        mockMvc.perform(post(<span class="string">&quot;/register&quot;</span>)</span><br><span class="line">                .contentType(APPLICATION_JSON)</span><br><span class="line">                .content(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    &#123;&quot;email&quot;: &quot;%s&quot;, &quot;name&quot;: &quot;Alice&quot;&#125;</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>.formatted(email)))</span><br><span class="line">               .andExpect(status().isConflict()); <span class="comment">// 409</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerUser_success_returns201</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="keyword">when</span>(userService.register(any(User.class))).thenReturn(<span class="number">123L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When &amp; Then</span></span><br><span class="line">        mockMvc.perform(post(<span class="string">&quot;/register&quot;</span>)</span><br><span class="line">                .contentType(APPLICATION_JSON)</span><br><span class="line">                .content(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    &#123;&quot;email&quot;: &quot;new@example.com&quot;, &quot;name&quot;: &quot;Bob&quot;&#125;</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>))</span><br><span class="line">               .andExpect(status().isCreated())</span><br><span class="line">               .andExpect(jsonPath(<span class="string">&quot;$.id&quot;</span>).value(<span class="number">123</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🔴 此时测试失败（因为 Controller 还没写）</p>
</blockquote>
<hr>
<p>步骤 2：写最小实现（绿）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserController.java</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; register(<span class="meta">@RequestBody</span> User user) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userService.isEmailExists(user.getEmail())) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(CONFLICT).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> userService.register(user);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(CREATED).body(Map.of(<span class="string">&quot;id&quot;</span>, id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserService.java（接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmailExists</span><span class="params">(String email)</span>;</span><br><span class="line">    Long <span class="title function_">register</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🟢 测试通过！</p>
</blockquote>
<hr>
<p>步骤 3：重构 + 补充单元测试</p>
<ul>
<li>为 <code>UserService</code> 实现类写单元测试</li>
<li>验证业务逻辑（如密码加密、事件发布等）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserServiceImplTest.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserRepository</span> <span class="variable">repo</span> <span class="operator">=</span> Mockito.mock(UserRepository.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>(repo);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register_savesUserAndReturnsId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;new@example.com&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        <span class="keyword">when</span>(repo.save(any())).thenAnswer(inv -&gt; &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">saved</span> <span class="operator">=</span> inv.getArgument(<span class="number">0</span>);</span><br><span class="line">            saved.setId(<span class="number">999L</span>);</span><br><span class="line">            <span class="keyword">return</span> saved;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> service.register(input);</span><br><span class="line"></span><br><span class="line">        assertEquals(<span class="number">999L</span>, id);</span><br><span class="line">        verify(repo).save(argThat(u -&gt; u.getEmail().equals(<span class="string">&quot;new@example.com&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>首先事务就是一组操作，要么全成功，要么全失败。</p>
<p>然后传统Java EE 开发有两种事务方式：一种是全局事务，太重太麻烦，目的是同事操作多个资源，比如该数据库+发消息到MQ，要么两者都成功要么都失败，用Java Transaction API 用JTA，通常运行在应用服务器里面，因为必须用到JNDI（这个只有重服务器里面有这个服务器里的 “资源注册表”）所以轻服务器用不了。另一种是本地事务，只能管理一个资源，最大的劣势了这个就是。</p>
<p><strong>现在Spring有独立的JTA组件，只需要在代码加@Transactional注解，配置里写清楚资源信息，轻服务器也能跑了</strong></p>
<p>Spring提供两种事务管理方式</p>
<p>1、声明式事务（推荐）</p>
<p>通过注解或 XML 配置，<strong>无需写事务代码</strong>，由 Spring 自动管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>  <span class="comment">// ← 声明式事务：方法执行前后自动开启/提交/回滚事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        emailService.sendWelcomeEmail(user.getEmail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚙️ 底层基于 AOP 实现：Spring 会为该方法创建代理，在调用前后插入事务控制逻辑。</p>
</blockquote>
<p>2、编程式事务（灵活但繁琐）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        emailService.sendWelcomeEmail(user.getEmail());</span><br><span class="line">        transactionManager.commit(status); <span class="comment">// 提交</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        transactionManager.rollback(status); <span class="comment">// 回滚</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么Spring层管理事务？事务不是MySQL的事吗？</strong></p>
<p>因为使用Spring管理事务无论换Oracle还是MySQL或者别的数据库都能一行搞定，开发者不需要关心底层用的是哪种持久化技术。</p>
<h3 id="Spring事务的抽象"><a href="#Spring事务的抽象" class="headerlink" title="Spring事务的抽象"></a>Spring事务的抽象</h3><p>了解一下Spring事务的顶层抽象。</p>
<p>Spring事务的核心 是 <strong>TransactionManager 接口</strong></p>
<p>这个接口有两个主要实现：</p>
<p><code>PlatformTransactionManager</code>  用于传统阻塞应用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition def)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span>;</span><br></pre></td></tr></table></figure>
<p><code>ReactiveTransactionManager</code> 用于响应式编程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;ReactiveTransaction&gt; <span class="title function_">getReactiveTransaction</span><span class="params">(...)</span>;</span><br><span class="line">Mono&lt;Void&gt; <span class="title function_">commit</span><span class="params">(...)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>这两个实现都是由Spring内部使用，但是也可以编程调用</strong></p>
<h3 id="配置-Transactional"><a href="#配置-Transactional" class="headerlink" title="配置@Transactional"></a>配置@Transactional</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Propagation（传播行为）</strong></td>
<td>方法被调用时，如何参与事务？ 例如：加入现有事务（<code>REQUIRED</code>） or 新开一个（<code>REQUIRES_NEW</code>）</td>
</tr>
<tr>
<td><strong>Isolation（隔离级别）</strong></td>
<td>防止脏读、不可重复读、幻读等并发问题</td>
</tr>
<tr>
<td><strong>Timeout（超时）</strong></td>
<td>事务最多执行多久，超时自动回滚</td>
</tr>
<tr>
<td><strong>Read-only（只读）</strong></td>
<td>查询操作设为只读，可优化性能（比如 <strong>不生成 redo/undo 日志</strong>）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>如果使用编程式事务中会有用到TransactionStatus</strong></p>
<p>这个是事务执行时的状态控制的，然后在编程式事务中可以通过它</p>
<ul>
<li>判断是否是新事务：<code>isNewTransaction()</code></li>
<li>手动标记回滚：<code>setRollbackOnly()</code></li>
<li>检查是否已完成：<code>isCompleted()</code></li>
</ul>
<p><strong>上面提到Spring内部实现了一套实现，我们只需要修改配置即可轻松切换全局事务还是本地事务，那么这里需要有不同的配置</strong></p>
<p><strong>不同数据访问技术，对应不同的 <code>TransactionManager</code> 实现</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>技术</th>
<th>事务管理器类</th>
<th>配置要点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>纯 JDBC</strong></td>
<td><code>DataSourceTransactionManager</code></td>
<td>需要注入 <code>DataSource</code></td>
</tr>
<tr>
<td><strong>Hibernate</strong></td>
<td><code>HibernateTransactionManager</code></td>
<td>需要注入 <code>SessionFactory</code></td>
</tr>
<tr>
<td><strong>JPA</strong></td>
<td><code>JpaTransactionManager</code></td>
<td>需要注入 <code>EntityManagerFactory</code></td>
</tr>
<tr>
<td><strong>JTA（全局事务）</strong></td>
<td><code>JtaTransactionManager</code></td>
<td><strong>不需要</strong>指定数据源，由应用服务器管理</td>
</tr>
</tbody>
</table>
</div>
<p>那么这里需要再JavaConfig里面手动配置对应的类了然后Spring会帮我们自动注入，然后在事务启动的时候会自己调用对应的Manager来对应事务了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 JTA 对应的事务管理器：JtaTransactionManager</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">txManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不需要注入 DataSource！因为 JTA 由应用服务器或独立组件（如 Atomikos）管理资源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JtaTransactionManager</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事务同步"><a href="#事务同步" class="headerlink" title="事务同步"></a>事务同步</h3><ul>
<li><p>使用 Spring 封装好的模板类或代理，比如：</p>
<ul>
<li><code>JdbcTemplate</code>（用于 JDBC）</li>
<li>带事务感知的 <code>SessionFactory</code> / <code>EntityManagerFactory</code> Bean（用于 Hibernate/JPA）</li>
</ul>
</li>
<li><p>好处：</p>
<ul>
<li><p>自动处理：<strong>连接创建、复用、关闭、异常转换、事务同步</strong></p>
</li>
<li><p>你的代码只写业务逻辑，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.query(&quot;SELECT * FROM users&quot;, rowMapper);</span><br></pre></td></tr></table></figure>
<p>→ 完全不用管 Connection 从哪来、要不要关。</p>
</li>
</ul>
</li>
</ul>
<p>事务同步的核心是：<strong>让 “资源操作”（比如 JDBC 查询 / 修改、MQ 发送）和 “事务生命周期”（开启→准备→提交 / 回滚）同步</strong></p>
<p>Spring 是通过「<code>TransactionSynchronizationManager</code>（事务同步管理器）+ 线程局部变量（ThreadLocal）+ 同步回调接口」实现的。</p>
<h3 id="声明式事务机制"><a href="#声明式事务机制" class="headerlink" title="声明式事务机制"></a>声明式事务机制</h3><p>上面我们知道用@Transactional 然后将@EnableTransactionManagement 添加到配置中就能使用事务了，但是这还不够，这里讲解一下Spring框架如何实现声明式事务的。</p>
<p><strong>内部通过 AOP代理 + 事务拦截器TransactionInterceptor + 事务管理器TransactionManager 实现</strong></p>
<p>用AOP代理包装目标服务，用注解/XML 定义事务规则，比如那些方法只读，哪些需要读写，最终由事务管理器驱动事物的开启、提交或者回滚。</p>
<p>Spring声明式事务关键靠3个核心组件协同工作</p>
<p>1、AOP动态代理，Spring返回的是一个代理对象</p>
<p>2、事务元数据，在@Transactional里面读取事务的元数据，告诉Spring那些方法需要事务，事务是什么类型只读，超时时间等等。</p>
<p>3、<strong>事务拦截器 + 事务管理器</strong>，代理对象运行的时候会触发拦截器，拦截器先读取事务元数据，再调用对应的事务管理器（比如 JDBC 用特定的事务管理器） ，然后由事务管理器把Spring容器的生命周期和事务的生命周期结合一起，开启，执行，提交或回滚事务的全流程。</p>
<h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h3><p>上面说到我们的事务的生命周期交给了事务管理器，那么事务管理器会自动帮我们回滚，这里讲一下事务管理器回滚机制。</p>
<p><strong>触发机制</strong></p>
<p>Spring默认只对未检查异常也就是RuntimException 和 Error 自动回滚事务。</p>
<p>受检查异常 不会触发回滚，除非显示配置。</p>
<p><strong>声明式回滚配置方式</strong></p>
<p>通过注解方式在@Transactional 里面配置</p>
<ul>
<li><code>rollbackFor</code> / <code>noRollbackFor</code>：传入具体的异常 <strong>Class 对象</strong>（类型安全）。</li>
<li><code>rollbackForClassName</code> / <code>noRollbackForClassName</code>：传入异常的 <strong>全限定类名字符串</strong>（基于模式匹配，需谨慎使用）。</li>
</ul>
<p>在 <strong>Spring5.2+</strong>支持Vavr Try</p>
<h3 id="Transactional-使用细节"><a href="#Transactional-使用细节" class="headerlink" title="@Transactional 使用细节"></a>@Transactional 使用细节</h3><p>这是个元数据，本身不执行事务逻辑，而是为Spring提供事务语义的生命，实际事务行为由Spring的事务基础设施在运行的时候根据这些元数据自动应用。                                                                                                                   </p>
<p>1、基本用法</p>
<ul>
<li>可在 <strong>类级别</strong> 或 <strong>方法级别</strong> 使用@Transactional<ul>
<li>类级别：为所有public方法提供默认事务配置</li>
<li>方法级别：覆盖类级别的设置 （方法优先级别更高）</li>
</ul>
</li>
<li>需配合启用注解启动</li>
</ul>
<p><strong>默认事务设置</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>传播行为（propagation）</td>
<td><code>REQUIRED</code></td>
<td>若存在事务则加入，否则新建</td>
</tr>
<tr>
<td>隔离级别（isolation）</td>
<td><code>DEFAULT</code></td>
<td>使用数据库默认隔离级别</td>
</tr>
<tr>
<td>读写模式（readOnly）</td>
<td><code>false</code></td>
<td>读写事务</td>
</tr>
<tr>
<td>超时（timeout）</td>
<td><code>-1</code></td>
<td>使用底层事务系统的默认超时（若不支持则无超时）</td>
</tr>
<tr>
<td>回滚规则</td>
<td>仅 <code>RuntimeException</code> 和 <code>Error</code> 触发回滚</td>
<td><strong>受检异常（checked exception）不会自动回滚</strong></td>
</tr>
</tbody>
</table>
</div>
<p><strong>其他可自定义属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value</code> / <code>transactionManager</code></td>
<td><code>String</code></td>
<td>指定使用的事务管理器 Bean 名称或 qualifier</td>
</tr>
<tr>
<td><code>label</code></td>
<td><code>String[]</code></td>
<td>为事务添加标签（可用于监控、重试等扩展逻辑）</td>
</tr>
<tr>
<td><code>propagation</code></td>
<td><code>Propagation</code> 枚举</td>
<td>设置事务传播行为（如 <code>REQUIRES_NEW</code>）</td>
</tr>
<tr>
<td><code>isolation</code></td>
<td><code>Isolation</code> 枚举</td>
<td>设置隔离级别（<strong>仅当传播行为为 <code>REQUIRED</code> 或 <code>REQUIRES_NEW</code> 时有效</strong>）</td>
</tr>
<tr>
<td><code>timeout</code> / <code>timeoutString</code></td>
<td><code>int</code> / <code>String</code></td>
<td>设置事务超时时间（秒），同样<strong>仅对新建事务有效</strong></td>
</tr>
<tr>
<td><code>readOnly</code></td>
<td><code>boolean</code></td>
<td>声明为只读事务（可优化性能），<strong>也仅在新建事务时生效</strong></td>
</tr>
<tr>
<td><code>rollbackFor</code> / <code>rollbackForClassName</code></td>
<td><code>Class[]</code> / <code>String[]</code></td>
<td>指定哪些<strong>异常（包括 checked）应触发回滚</strong></td>
</tr>
<tr>
<td><code>noRollbackFor</code> / <code>noRollbackForClassName</code></td>
<td><code>Class[]</code> / <code>String[]</code></td>
<td>指定哪些<strong>异常不应触发回滚</strong>（即使它们是 RuntimeException）</td>
</tr>
</tbody>
</table>
</div>
<p>2、关键限制</p>
<p>首先他是用AOP代理机制的，所以自调用无效就是用this调用方法就会失效。<strong>仅 public 方法有效</strong> 其他的加了注解也不会生效</p>
<p>如果一定要用的话：使用AspectJ 编译时或者加载时植入 ，可支持任意方法。</p>
<p><strong>AspectJ</strong></p>
<p>这个是独立的、功能更强的AOP框架核心能力是支持编译时植入，加载时织入，简单说就是 “在代码运行前 / 运行时，把 AOP 逻辑（比如事务拦截）直接嵌入到目标类的字节码中”—— 不用依赖动态代理，自然能捕获到自调用、private 方法。</p>
<p><strong>3、多事务管理器</strong></p>
<p>大多数应用只需一个事务管理器，但是复杂场景可能需要多个。</p>
<p>就是不同的数据库需要特定的事务管理器，如果一个项目里，既要用到JDBC又要用到 JPA ，那么这时候需要配置多事务管理器。</p>
<p>核心流程：配置多个事务管理器Bean，并用@Qualifier 标记唯一标识，然后再@Transactional 中通过value 或者 tansactionManager属性，指定使用哪个事务管理器。</p>
<p>先配置Java Config</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 开启事务支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiTxManagerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------- 订单库（JDBC）事务管理器 --------------------------</span></span><br><span class="line">    <span class="comment">// 1. 配置订单库数据源（独立数据源）</span></span><br><span class="line">    <span class="meta">@Bean(&quot;orderDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">orderDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置订单库连接池（如Druid），省略细节</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.alibaba.druid.pool.DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 配置订单库事务管理器，用@Qualifier标记标识：orderTxManager</span></span><br><span class="line">    <span class="meta">@Bean(&quot;orderTxManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">orderTxManager</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;orderDataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="comment">// JDBC对应的事务管理器，绑定订单库数据源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------- 用户库（JPA）事务管理器 --------------------------</span></span><br><span class="line">    <span class="comment">// 1. 配置用户库EntityManagerFactory（JPA核心组件）</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userEmf&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> EntityManagerFactory <span class="title function_">userEntityManagerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置JPA（如Hibernate），绑定用户库数据源，省略细节</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean().getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 配置用户库事务管理器，用@Qualifier标记标识：userTxManager</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userTxManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">userTxManager</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;userEmf&quot;)</span> EntityManagerFactory emf)</span> &#123;</span><br><span class="line">        <span class="comment">// JPA对应的事务管理器，绑定用户库EntityManagerFactory</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JpaTransactionManager</span>(emf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再@Transactional里面引用对应的Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiDbService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------- 操作订单库：指定订单库事务管理器 ---------------</span></span><br><span class="line">    <span class="comment">// 方式1：用value属性（简写）指定事务管理器标识</span></span><br><span class="line">    <span class="meta">@Transactional(value = &quot;orderTxManager&quot;, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 操作订单库（JDBC/MyBatis），事务由orderTxManager管理</span></span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------- 操作用户库：指定用户库事务管理器 ---------------</span></span><br><span class="line">    <span class="comment">// 方式2：用transactionManager属性（全称）指定</span></span><br><span class="line">    <span class="meta">@Transactional(transactionManager = &quot;userTxManager&quot;, readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="comment">// 操作用户库（JPA），事务由userTxManager管理</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(userId).orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------- 同时操作两个库：两个独立事务（非分布式） ---------------</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrderAndUser</span><span class="params">(Order order, User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用两个带事务的方法，各自用自己的事务管理器，互不影响</span></span><br><span class="line">        createOrder(order); <span class="comment">// 订单库事务：失败回滚订单操作</span></span><br><span class="line">        getUserById(user.getId()); <span class="comment">// 用户库事务：失败回滚用户操作</span></span><br><span class="line">        <span class="comment">// 注意：如果createOrder成功，getUserById失败，订单库事务已提交，不会回滚！</span></span><br><span class="line">        <span class="comment">// 若需“要么都成要么都败”，需用分布式事务（如JTA），而非两个独立事务管理器</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>   <strong>如果担心注解长度过长可以自定义注解。</strong>              </p>
<p><strong>事务传播配置</strong></p>
<p>1、 <strong><code>PROPAGATION_REQUIRED</code>（默认行为）</strong></p>
<ul>
<li><strong>行为</strong>：如果当前存在事务，则加入该事务；否则新建一个事务。</li>
<li><strong>物理事务</strong>：所有嵌套调用共享<strong>同一个物理事务</strong>。</li>
<li><strong>逻辑事务</strong>：每个方法有自己的<strong>逻辑事务作用域</strong>，可独立设置回滚状态。</li>
<li>关键特性<ul>
<li>内部方法标记回滚 → <strong>整个物理事务都会回滚</strong>。</li>
<li>如果外部不知道内部已标记回滚，仍尝试提交 → Spring 会抛出 <strong><code>UnexpectedRollbackException</code></strong>，防止误以为提交成功。</li>
</ul>
</li>
<li><strong>注意</strong>：内部事务的隔离级别、超时、只读等设置<strong>通常被忽略</strong>（除非开启 <code>validateExistingTransactions = true</code> 来严格校验）。</li>
</ul>
<hr>
<ol>
<li><strong><code>PROPAGATION_REQUIRES_NEW</code></strong></li>
</ol>
<ul>
<li><strong>行为</strong>：<strong>总是挂起（suspend）当前事务</strong>，并启动一个<strong>全新的、独立的物理事务</strong>。</li>
<li>特点<ul>
<li>内外事务完全隔离：各自拥有独立的提交/回滚、锁、隔离级别、超时等。</li>
<li>内部事务回滚 <strong>不会影响</strong> 外部事务。</li>
<li>适用于需要“无论外部如何，我都要独立完成”的场景（如日志记录、审计）。</li>
</ul>
</li>
</ul>
<hr>
<ol>
<li><strong><code>PROPAGATION_NESTED</code></strong></li>
</ol>
<ul>
<li><strong>行为</strong>：在<strong>同一个物理事务中创建保存点（savepoint）</strong>，实现部分回滚。</li>
<li>机制<ul>
<li>若内部失败，可回滚到保存点，外部事务仍可继续并最终提交。</li>
<li>成功时，保存点释放，变更合并到主事务。</li>
</ul>
</li>
<li><p>限制</p>
<ul>
<li><strong>仅支持 JDBC 资源事务</strong>（如 <code>DataSourceTransactionManager</code>）。</li>
<li>不适用于 JTA 或 Hibernate 等不支持保存点的事务管理器。</li>
</ul>
</li>
<li><p><code>REQUIRED</code> 共享事务（回滚全局生效），</p>
</li>
<li><code>REQUIRES_NEW</code> 完全独立事务，</li>
<li><code>NESTED</code> 通过保存点实现局部回滚（仅限 JDBC）。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://oyy0v0.top">oyy0v0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://oyy0v0.top/2025/10/23/2025-10-23%20Spring/">https://oyy0v0.top/2025/10/23/2025-10-23%20Spring/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://oyy0v0.top" target="_blank">oyy0v0😼</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/">-Spring全家桶</a></div><div class="post_share"><div class="social-share" data-image="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/10/28/2025-10-28%20JavaEE/" title="JavaEE"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaEE</div></div></a></div><div class="next-post pull-right"><a href="/2025/10/22/2025-10-22%20%E5%8E%8B%E6%B5%8B/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/10/12/2025-10-13%20mybatis%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/" title="Mybatis的执行原理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-12</div><div class="title">Mybatis的执行原理</div></div></a></div><div><a href="/2024/08/07/2024-8-7%20Springboot/" title="Springboot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="title">Springboot</div></div></a></div><div><a href="/2024/07/20/2025-10-20%20Mybatis/" title="Mybatis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="title">Mybatis</div></div></a></div><div><a href="/2025/11/23/2025-11-22%20Spring%E6%94%B6%E5%BD%95%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Spring面试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-23</div><div class="title">Spring面试</div></div></a></div><div><a href="/2025/10/30/2025-10-30%20Spring%E6%89%A9%E5%B1%95%E7%82%B9%E6%A1%88%E4%BE%8B/" title="Spring扩展点案例"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-30</div><div class="title">Spring扩展点案例</div></div></a></div><div><a href="/2025/11/23/2025-11-23%20SpringMVC/" title="SpringMVC"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-23</div><div class="title">SpringMVC</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/7.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">oyy0v0</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/oyy0v0"><i class="fab fa-github"></i><span>💕前往小家</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/assets/QRCode.jpg" target="_blank" title="icon-weixin"><i class="微信" style="color: faa-tada;"></i></a><a class="social-icon" href="https://github.com/oyy0v0" target="_blank" title="icon-github"><i class="Github" style="color: faa-tade;"></i></a><a class="social-icon" href="mailto:2925886492@qq.com" target="_blank" title="icon-youxiang"><i class="QQ邮箱" style="color: faa-tada;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="toc-text">核心技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC%E5%AE%B9%E5%99%A8"><span class="toc-text">IOC容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-IoC%E5%AE%B9%E5%99%A8%E5%92%8CBean%E7%AE%80%E4%BB%8B"><span class="toc-text">Spring IoC容器和Bean简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-IoC%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">Spring IoC容器的两个核心组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">Bean的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IOC%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">IOC容器的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring-IoC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-text">Spring IoC容器的工作机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplicationContext%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">ApplicationContext的具体实现和使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">配置元数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8"><span class="toc-text">实例化一个容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E3%80%81%E7%BB%84%E7%BB%87Spring%E7%9A%84XML%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">拆分、组织Spring的XML配置元数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">使用容器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E6%A6%82%E8%A7%88"><span class="toc-text">Bean概览</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Bean%E5%8C%85%E5%90%AB%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">Bean包含的核心信息与容器的关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96Bean"><span class="toc-text">实例化Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DI%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">DI依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%B5%81%E7%A8%8B"><span class="toc-text">循环依赖流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%E7%BB%86%E8%8A%82"><span class="toc-text">依赖配置细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">Bean的作用域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">Bean的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%89%A9%E5%B1%95%E7%82%B9"><span class="toc-text">容器扩展点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BeanPostProcessor-%E6%8E%A5%E5%8F%A3"><span class="toc-text">BeanPostProcessor 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BeanFactoryPostProcessor%E6%8E%A5%E5%8F%A3"><span class="toc-text">BeanFactoryPostProcessor接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FactoryBean%E6%8E%A5%E5%8F%A3"><span class="toc-text">FactoryBean接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">基于注解的容器配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Autowired-%E6%8C%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">@Autowired 按类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E4%B8%8D%E5%94%AF%E4%B8%80%E9%97%AE%E9%A2%98"><span class="toc-text">解决类型匹配不唯一问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Resource-%E6%8C%89%E5%90%8D%E5%AD%97"><span class="toc-text">@Resource 按名字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Value-%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5"><span class="toc-text">@Value 属性注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PostConstruct-%E5%92%8C-PreDestory"><span class="toc-text">@PostConstruct 和 @PreDestory</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%89%AB%E6%8F%8F%E5%92%8C%E7%AE%A1%E7%90%86"><span class="toc-text">配置扫描和管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9AClasspath%E6%89%AB%E6%8F%8F"><span class="toc-text">1、核心机制：Classpath扫描</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Component%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F"><span class="toc-text">@Component注解及其衍生</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%85%83%E6%B3%A8%E8%A7%A3%E5%92%8C%E7%BB%84%E5%90%88%E6%B3%A8%E8%A7%A3"><span class="toc-text">2、元注解和组合注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E6%9C%BA%E5%88%B6"><span class="toc-text">扫描机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%89%AB%E6%8F%8F%E8%BF%87%E6%BB%A4"><span class="toc-text">3、扫描过滤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89Bean%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">在组件中定义Bean元数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E7%BB%84%E4%BB%B6%E5%92%8C%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">4、自动扫描组件和命名规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">自动扫描组件的作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">作用域代理的两种类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90-Resources"><span class="toc-text">资源 Resources</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource%E6%8E%A5%E5%8F%A3"><span class="toc-text">Resource接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84Resource%E5%AE%9E%E7%8E%B0"><span class="toc-text">内置的Resource实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP"><span class="toc-text">Spring AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B0%E6%A6%82%E5%BF%B5"><span class="toc-text">AOP中的各种新概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-text">AOP通知类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E5%AE%9E%E8%B7%B5"><span class="toc-text">AOP实践</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E7%94%A8-AspectJ%E9%85%8D%E7%BD%AE"><span class="toc-text">启用@AspectJ配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAAspect"><span class="toc-text">声明一个Aspect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%88%87%E7%82%B9"><span class="toc-text">声明切点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8EAdvice"><span class="toc-text">声明Advice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Introduction%E5%BC%95%E5%85%A5"><span class="toc-text">Introduction引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">可能会出现的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-text">测试的重要概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Spring%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-text">如何使用Spring进行测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E6%B5%8B%E8%AF%95%EF%BC%88%E5%8F%AA%E5%8A%A0%E8%BD%BD%E5%BF%85%E8%A6%81%E7%BB%84%E4%BB%B6%EF%BC%89"><span class="toc-text">切片测试（只加载必要组件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web-%E5%B1%82%E6%B5%8B%E8%AF%95%EF%BC%88MockMvc%EF%BC%89"><span class="toc-text">Web 层测试（MockMvc）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-text">Spring事务的抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-Transactional"><span class="toc-text">配置@Transactional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%90%8C%E6%AD%A5"><span class="toc-text">事务同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6"><span class="toc-text">声明式事务机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A"><span class="toc-text">事务回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transactional-%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-text">@Transactional 使用细节</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2026 By oyy0v0</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.oyy0v0.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.oyy0v0.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="//at.alicdn.com/t/c/font_4658720_723un29n3vn.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/18.jpg);"> <a class="categoryBar-list-link" href="categories/java入门/">java入门</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">java</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/17.jpg);"> <a class="categoryBar-list-link" href="categories/博客/">博客</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">算法</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/15.jpg);"> <a class="categoryBar-list-link" href="categories/前端/">前端</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">博客</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/14.jpg);"> <a class="categoryBar-list-link" href="categories/GitHub/">GitHub</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">AI</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/13.jpg);"> <a class="categoryBar-list-link" href="categories/算法/">算法</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr">前端</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/12.jpg);"> <a class="categoryBar-list-link" href="categories/java/">java</a><span class="categoryBar-list-count">36</span><span class="categoryBar-list-descr">GitHub</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/11.jpg);"> <a class="categoryBar-list-link" href="categories/AI/">AI</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">八股文</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/10.jpg);"> <a class="categoryBar-list-link" href="categories/面试集合/">面试集合</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">面试集合</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/2.jpg);"> <a class="categoryBar-list-link" href="categories/Go语言/">Go语言</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">Go语言</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/20.jpg);"> <a class="categoryBar-list-link" href="categories/操作系统/">操作系统</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">Linux</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/21.jpg);"> <a class="categoryBar-list-link" href="categories/计算机网络/">计算机网络</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">操作系统</span></li><li class="categoryBar-list-item" style="background:url(https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/22.jpg);"> <a class="categoryBar-list-link" href="categories/踩坑杂记/">踩坑杂记</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">计算机网络</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '8b4e8faa226f49ff851d67d0354499b7';
  var gaud_map_key = '85e43a6ba1ebb38fd12b0d8a886ecb9b';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/07/28/2025-6-18 八股文/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/23.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-07-28</span><a class="blog-slider__title" href="2025/07/28/2025-6-18 八股文/" alt="">八股文集合</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/07/28/2025-6-18 八股文/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/10/14/2025-10-14 Java线程池的原理/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-14</span><a class="blog-slider__title" href="2025/10/14/2025-10-14 Java线程池的原理/" alt="">Java线程池的原理</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/10/14/2025-10-14 Java线程池的原理/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/29/2024-8-29 Solr/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-29</span><a class="blog-slider__title" href="2024/08/29/2024-8-29 Solr/" alt="">Solr</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/08/29/2024-8-29 Solr/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/24/2024-8-24 虚拟机VMware/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/18.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-24</span><a class="blog-slider__title" href="2024/08/24/2024-8-24 虚拟机VMware/" alt="">虚拟机</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/08/24/2024-8-24 虚拟机VMware/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/26/2024-11-26设计模式/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-26</span><a class="blog-slider__title" href="2024/11/26/2024-11-26设计模式/" alt="">设计模式</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/11/26/2024-11-26设计模式/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/26/2024-11-22 面试/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/15.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-26</span><a class="blog-slider__title" href="2024/11/26/2024-11-22 面试/" alt="">面试集合</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/11/26/2024-11-22 面试/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/01/06/2026-1-5 SpringCloud/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/21.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-01-06</span><a class="blog-slider__title" href="2026/01/06/2026-1-5 SpringCloud/" alt="">SpringCloud</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2026/01/06/2026-1-5 SpringCloud/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/02/05/2026-2-5 SpringSecurity/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-02-05</span><a class="blog-slider__title" href="2026/02/05/2026-2-5 SpringSecurity/" alt="">SpringSecurity</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2026/02/05/2026-2-5 SpringSecurity/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/02/17/2026-2-17 RocketMQ/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-02-17</span><a class="blog-slider__title" href="2026/02/17/2026-2-17 RocketMQ/" alt="">RocketMQ</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2026/02/17/2026-2-17 RocketMQ/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/01/25/2026-1-25 zookeeper/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/10.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-01-25</span><a class="blog-slider__title" href="2026/01/25/2026-1-25 zookeeper/" alt="">zookeeper</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2026/01/25/2026-1-25 zookeeper/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/01/21/2026-1-21 Elasticsearch/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/20.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-01-21</span><a class="blog-slider__title" href="2026/01/21/2026-1-21 Elasticsearch/" alt="">Elasticsearch</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2026/01/21/2026-1-21 Elasticsearch/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/03/11/2025-3-22 开发流程化/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-11</span><a class="blog-slider__title" href="2025/03/11/2025-3-22 开发流程化/" alt="">开发流程化</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/03/11/2025-3-22 开发流程化/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/03/11/2025-3-14 JSP/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/20.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-11</span><a class="blog-slider__title" href="2025/03/11/2025-3-14 JSP/" alt="">JSP</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/03/11/2025-3-14 JSP/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/03/11/2025-3-14 Servlet入门/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/21.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-11</span><a class="blog-slider__title" href="2025/03/11/2025-3-14 Servlet入门/" alt="">Servlet入门</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/03/11/2025-3-14 Servlet入门/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/03/11/2025-3-12 常用注解/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-11</span><a class="blog-slider__title" href="2025/03/11/2025-3-12 常用注解/" alt="">常用注解</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/03/11/2025-3-12 常用注解/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/03/11/2025-3-14  Servlet进阶/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/15.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-11</span><a class="blog-slider__title" href="2025/03/11/2025-3-14  Servlet进阶/" alt="">Servlet进阶</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/03/11/2025-3-14  Servlet进阶/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/03/11/2025-3-11 Maven实战/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/21.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-11</span><a class="blog-slider__title" href="2025/03/11/2025-3-11 Maven实战/" alt="">Maven</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/03/11/2025-3-11 Maven实战/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/12/14/2025-12-14 SpringBoot3/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-12-14</span><a class="blog-slider__title" href="2025/12/14/2025-12-14 SpringBoot3/" alt="">Springboot3</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/12/14/2025-12-14 SpringBoot3/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/2025-11-26 Redis/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/2025-11-26 Redis/" alt="">redis</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/08/23/2025-11-26 Redis/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/12/03/2025-12-03 Redis高级篇/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/12.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-12-03</span><a class="blog-slider__title" href="2025/12/03/2025-12-03 Redis高级篇/" alt="">redis 高级篇</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/12/03/2025-12-03 Redis高级篇/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/11/23/2025-11-23 SpringMVC/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-11-23</span><a class="blog-slider__title" href="2025/11/23/2025-11-23 SpringMVC/" alt="">SpringMVC</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/11/23/2025-11-23 SpringMVC/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/10/30/2025-10-30 Spring扩展点案例/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-30</span><a class="blog-slider__title" href="2025/10/30/2025-10-30 Spring扩展点案例/" alt="">Spring扩展点案例</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/10/30/2025-10-30 Spring扩展点案例/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/10/23/2025-10-23 Spring/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/17.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-23</span><a class="blog-slider__title" href="2025/10/23/2025-10-23 Spring/" alt="">Spring</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/10/23/2025-10-23 Spring/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/11/23/2025-11-22 Spring收录面试题/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-11-23</span><a class="blog-slider__title" href="2025/11/23/2025-11-22 Spring收录面试题/" alt="">Spring面试</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/11/23/2025-11-22 Spring收录面试题/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/10/28/2025-10-28 JavaEE/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-28</span><a class="blog-slider__title" href="2025/10/28/2025-10-28 JavaEE/" alt="">JavaEE</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/10/28/2025-10-28 JavaEE/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/10/22/2025-10-22 Netty了解/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-22</span><a class="blog-slider__title" href="2025/10/22/2025-10-22 Netty了解/" alt="">Netty</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/10/22/2025-10-22 Netty了解/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/10/22/2025-10-22 Sentinel限流和熔断/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231208202901.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-22</span><a class="blog-slider__title" href="2025/10/22/2025-10-22 Sentinel限流和熔断/" alt="">Sentinel限流和熔断</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/10/22/2025-10-22 Sentinel限流和熔断/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/14/2025-10-21 Dubbo/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-14</span><a class="blog-slider__title" href="2024/08/14/2025-10-21 Dubbo/" alt="">Dubbo</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/08/14/2025-10-21 Dubbo/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/07/20/2025-10-20 Mybatis/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/11.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-20</span><a class="blog-slider__title" href="2024/07/20/2025-10-20 Mybatis/" alt="">Mybatis</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/07/20/2025-10-20 Mybatis/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/07/2024-8-7 Springboot/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/23.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-07</span><a class="blog-slider__title" href="2024/08/07/2024-8-7 Springboot/" alt="">Springboot</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/08/07/2024-8-7 Springboot/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/10/12/2025-10-13 mybatis的执行原理/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-12</span><a class="blog-slider__title" href="2025/10/12/2025-10-13 mybatis的执行原理/" alt="">Mybatis的执行原理</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/10/12/2025-10-13 mybatis的执行原理/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/07/2024-8-9 固定思路详解/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/12.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-07</span><a class="blog-slider__title" href="2024/08/07/2024-8-9 固定思路详解/" alt="">固定思路详解</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/08/07/2024-8-9 固定思路详解/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/07/2024-8-7 踩坑记录/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/14.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-07</span><a class="blog-slider__title" href="2024/08/07/2024-8-7 踩坑记录/" alt="">踩坑记录</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/08/07/2024-8-7 踩坑记录/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/2024-8-23 Nginx和lua和Openresty高性能实践/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/14.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/2024-8-23 Nginx和lua和Openresty高性能实践/" alt="">Nginx+lua+OpenResty高性能实践</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/08/23/2024-8-23 Nginx和lua和Openresty高性能实践/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/14/2024-8-14 RPC远程服务调用/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/14.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-14</span><a class="blog-slider__title" href="2024/08/14/2024-8-14 RPC远程服务调用/" alt="">RPC远程服务调用</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/08/14/2024-8-14 RPC远程服务调用/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/16/2024-8-16 前端速通/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/15.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-16</span><a class="blog-slider__title" href="2024/08/16/2024-8-16 前端速通/" alt="">前端速通</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/08/16/2024-8-16 前端速通/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/06/24/2025-6-24 算法合集/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/22.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-06-24</span><a class="blog-slider__title" href="2025/06/24/2025-6-24 算法合集/" alt="">算法合集</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/06/24/2025-6-24 算法合集/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/03/10/2025-3-9 队列和栈/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/12.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-10</span><a class="blog-slider__title" href="2025/03/10/2025-3-9 队列和栈/" alt="">队列和栈</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/03/10/2025-3-9 队列和栈/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/03/02/2025-3-2 链表/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/21.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-02</span><a class="blog-slider__title" href="2025/03/02/2025-3-2 链表/" alt="">链表</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/03/02/2025-3-2 链表/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/03/11/2025-3-11 算法问题合集/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-11</span><a class="blog-slider__title" href="2025/03/11/2025-3-11 算法问题合集/" alt="">算法问题合集</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/03/11/2025-3-11 算法问题合集/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/02/23/2025-2-23 数组和字符串（算法）/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-02-23</span><a class="blog-slider__title" href="2025/02/23/2025-2-23 数组和字符串（算法）/" alt="">数组和字符串（算法）</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/02/23/2025-2-23 数组和字符串（算法）/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/03/02/2025-2-25 java8新特性/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/18.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-02</span><a class="blog-slider__title" href="2025/03/02/2025-2-25 java8新特性/" alt="">java8新特性</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/03/02/2025-2-25 java8新特性/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/12/16/2025-12-16 Java注解/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/18.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-12-16</span><a class="blog-slider__title" href="2025/12/16/2025-12-16 Java注解/" alt="">Java注解</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/12/16/2025-12-16 Java注解/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/11/07/2025-11-7 动态代理和反射/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/21.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-11-07</span><a class="blog-slider__title" href="2025/11/07/2025-11-7 动态代理和反射/" alt="">动态代理和反射</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/11/07/2025-11-7 动态代理和反射/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/11/04/2025-11-4 算法理解（口语化）/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/15.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-11-04</span><a class="blog-slider__title" href="2025/11/04/2025-11-4 算法理解（口语化）/" alt="">算法理解（口语化）</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/11/04/2025-11-4 算法理解（口语化）/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/10/20/2025-10-20 RPC了解/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231208202901.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-20</span><a class="blog-slider__title" href="2025/10/20/2025-10-20 RPC了解/" alt="">RPC了解</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2025/10/20/2025-10-20 RPC了解/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/15/2024-4-15 数据库/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/23.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-15</span><a class="blog-slider__title" href="2024/04/15/2024-4-15 数据库/" alt="">数据库</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/04/15/2024-4-15 数据库/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/07/13/2024-7-2 Vue2/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/21.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-13</span><a class="blog-slider__title" href="2024/07/13/2024-7-2 Vue2/" alt="">Vue2</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/07/13/2024-7-2 Vue2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/05/14/2024-4-29 计算机网络/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/14.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-05-14</span><a class="blog-slider__title" href="2024/05/14/2024-4-29 计算机网络/" alt="">计算机网络</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/05/14/2024-4-29 计算机网络/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/18/2024-4-20 操作系统/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-18</span><a class="blog-slider__title" href="2024/04/18/2024-4-20 操作系统/" alt="">操作系统</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/04/18/2024-4-20 操作系统/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/18/2024-4-18 JDBC/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-18</span><a class="blog-slider__title" href="2024/04/18/2024-4-18 JDBC/" alt="">JDBC</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/04/18/2024-4-18 JDBC/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/28/2024-4-28 go语言/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-28</span><a class="blog-slider__title" href="2024/04/28/2024-4-28 go语言/" alt="">Go语言</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2024/04/28/2024-4-28 go语言/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/08/15/2023-8-15 AI夏令营天气预报大赛/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/11.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-15</span><a class="blog-slider__title" href="2023/08/15/2023-8-15 AI夏令营天气预报大赛/" alt="">AI夏令营天气预报大赛</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2023/08/15/2023-8-15 AI夏令营天气预报大赛/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/07/06/2023-7-1Java小记/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-06</span><a class="blog-slider__title" href="2023/07/06/2023-7-1Java小记/" alt="">Java小记</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2023/07/06/2023-7-1Java小记/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/05/08/2023-5-8哈希表和有序表/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/22.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-08</span><a class="blog-slider__title" href="2023/05/08/2023-5-8哈希表和有序表/" alt="">哈希表和有序表</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2023/05/08/2023-5-8哈希表和有序表/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/06/23/2023-6-24Git和Github使用教程/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/15.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-23</span><a class="blog-slider__title" href="2023/06/23/2023-6-24Git和Github使用教程/" alt="">Git和Github使用教程</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2023/06/23/2023-6-24Git和Github使用教程/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/12/18/2023-12-18 前端小记/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/20.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-12-18</span><a class="blog-slider__title" href="2023/12/18/2023-12-18 前端小记/" alt="">前端小记</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2023/12/18/2023-12-18 前端小记/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/12/12/2023-12-11 建立博客保姆教程（1）/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-12-12</span><a class="blog-slider__title" href="2023/12/12/2023-12-11 建立博客保姆教程（1）/" alt="">建立博客</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2023/12/12/2023-12-11 建立博客保姆教程（1）/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/11/27/2022-11-27 枚举类/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oyy0v0pic.oss-cn-guangzhou.aliyuncs.com/20.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-27</span><a class="blog-slider__title" href="2022/11/27/2022-11-27 枚举类/" alt="">javase入门（枚举1）</a><div class="blog-slider__text">知识分享</div><a class="blog-slider__button" href="2022/11/27/2022-11-27 枚举类/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/about/'|| '/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://github-api.oyy0v0.top//api?oyy0v0",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'oyy0v0')
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>